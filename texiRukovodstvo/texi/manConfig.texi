@node CONFIG, Пример конфигурации OpenSSL, OpenSSL, Top
@chapter CONFIG
CONFIG(5)                           OpenSSL                          CONFIG(5)
@table @asis
@item NAME
       config - OpenSSL CONF файлы конфигурации библиотеки

@item DESCRIPTION
       Библиотека OpenSSL CONF может использоваться для чтения файлов
       конфигурации. Он используется для главного файла конфигурации
       OpenSSL openssl.cnf и в некоторых других местах, таких как
       файлы SPKAC и файлы расширений сертификатов для утилиты x509.
       Приложения OpenSSL также могут использовать библиотеку CONF для
       своих собственных целей.

       Файл конфигурации разделен на несколько разделов. Каждый раздел
       начинается со строки [ section_name ] и заканчивается, когда
       начинается новый раздел или достигается конец файла. Название
       раздела может состоять из буквенно-цифровых символов и символов
       подчеркивания.

       Первый раздел файла конфигурации является специальным и называется
       разделом по умолчанию. Этот раздел обычно безымянный и охватывает
       от начала файла до первого именованного раздела. Когда имя ищется,
       оно сначала ищется в именованном разделе (если есть), а затем в
       разделе по умолчанию.

       Среда отображается на раздел с именем ENV.

       Комментарии могут быть включены, с предшествующим им символом #

       Другие файлы могут быть включены с использованием директивы .include,
       за которой следует путь. Если путь указывает на каталог, все файлы
       с именами, заканчивающимися на .cnf или .conf, включаются из каталога.
       Рекурсивное включение каталогов из файлов в такой каталог не
       поддерживается. Это означает, что файлы во включенном каталоге
       также могут содержать директивы .include, но там поддерживается
       только включение обычных файлов. Включение каталогов не поддерживается
       в системах без поддержки POSIX IO.

       Настоятельно рекомендуется использовать абсолютные пути с директивой
       .include. Относительные пути оцениваются на основе текущего рабочего
       каталога приложения, поэтому, если файл конфигурации, содержащий
       директиву .include, не является специфическим для приложения,
       включение не будет работать должным образом.

       Каждый раздел в файле конфигурации состоит из нескольких пар имени
       и значения в форме name=value.

       Строка имени может содержать любые буквенно-цифровые символы, а
       также несколько знаков пунктуации, таких как . , ; и _.

       Строка значения состоит из строки, следующей за символом = до конца
       строки с удаленными пробелами в начале и в конце.

       Строка значения подвергается расширению переменной. Это можно сделать,
       включив форму $var или $@{var@}: это заменит значение именованной
       переменной в текущем разделе. Также возможно заменить значение из
       другого раздела, используя синтаксис $section::name или $@{section::name@}.
       С помощью формы $ ENV :: name можно заменить переменные окружения. Также
       возможно присвоить значения переменным среды, используя имя ENV::name,
       это будет работать, если программа ищет переменные среды, используя
       библиотеку CONF вместо прямого вызова getenv(). Строка значения не
       должна превышать длину 64k после раскрытия переменной. В противном
       случае произойдет ошибка.

       Можно экранировать определенные символы, используя кавычки любого типа
       или символ \. Сделав последний символ строки \, строку значений можно
       распределить по нескольким строкам. Кроме того, последовательности \n,
       \r, \b или \t распознаются.

       Все описанные выше правила раскрытия и экранирования, которые
       применяются к значению, также применяются к пути директивы .include.

@item OPENSSL LIBRARY CONFIGURATION
       Приложения могут автоматически настраивать определенные аспекты
       OpenSSL, используя главный файл конфигурации OpenSSL или,
       опционально, альтернативный файл конфигурации. Утилита openssl
       включает эту функциональность: любая подкоманда использует главный
       файл конфигурации OpenSSL, если в подкоманде не используется опция
       для использования альтернативного файла конфигурации.

       Чтобы включить настройку библиотеки, раздел по умолчанию должен
       содержать соответствующую строку, которая указывает на основной
       раздел конфигурации. Имя по умолчанию - openssl_conf, которое
       используется утилитой openssl. Другие приложения могут использовать
       альтернативное имя, например, myapplication_conf. Все строки
       конфигурации библиотеки отображаются в разделе по умолчанию в
       начале файла конфигурации.

       Раздел конфигурации должен состоять из набора пар имя-значение,
       которые содержат конкретную информацию о конфигурации модуля. Имя
       представляет собой имя модуля конфигурации. Значение значения
       зависит от модуля: оно может, например, представлять дополнительный
       раздел конфигурации, содержащий информацию, специфичную для модуля
       конфигурации. Как здесь:
@display
        # Это должно быть в разделе по умолчанию
        openssl_conf = openssl_init

        [openssl_init]

        oid_section = new_oids
        engines = engine_section

        [new_oids]

        ... new oids here ...

        [engine_section]

        ... engine stuff here ...
@end display
       Особенности каждого модуля конфигурации описаны ниже.

@item   ASN1 Object Configuration Module
       Этот модуль имеет имя oid_section. Значение этой переменной
       указывает на раздел, содержащий пары значений имени OID: имя -
       это короткое и полное имя OID, значение - числовая форма объекта OID.
       Хотя некоторые из подкоманд утилиты openssl уже имеют свои собственные
       функции раздела ASN1 OBJECT, не все это делают. Используя модуль
       конфигурации ASN1 OBJECT, все подкоманды утилиты openssl могут
       видеть новые объекты, а также любые совместимые приложения. Например:
@display
        [new_oids]

        some_new_oid = 1.2.3.4
        some_other_oid = 1.2.3.5
@end display
       Также возможно установить значение на полное имя, за которым
       следуют запятая и числовая форма OID. Например:
@display
        shortName = some object long name, 1.2.3.4
@end display
@item   Engine Configuration Module
       Этот модуль конфигурации ENGINE имеет название engine. Значение
       этой переменной указывает на раздел, содержащий дополнительную
       информацию о конфигурации ENGINE.

       Раздел, на который указывают движки, представляет собой таблицу
       имен движков (смотри engine_id below) и других разделов, содержащих
       информацию о конфигурации, специфичную для каждого ENGINE.

       Каждый специфический для ENGINE раздел используется для установки
       алгоритмов по умолчанию, загрузки динамического кода, выполнения
       инициализации и отправки ctrls. Фактическая операция зависит от
       имени команды, которое является именем пары имя-значение. В настоящее
       время поддерживаемые команды перечислены ниже.
@display
       Для примера:

        [engine_section]

        # Настройте ENGINE с именем "foo"
        foo = foo_section
        # Настройте ENGINE с именем "bar"
        bar = bar_section

        [foo_section]
        ... foo ENGINE конкретные команды ...

        [bar_section]
        ... "bar" ENGINE конкретные команды ...
@end display
       Команда engine_id используется для присвоения имени ENGINE.
       Если используется эта команда должна быть первой. Например:
@display
        [engine_section]
        # Это обычно обрабатывает объект ENGINE с именем "foo"
        foo = foo_section

        [foo_section]
        # Переопределите имя по умолчанию и используйте вместо него "myfoo".
        engine_id = myfoo
@end display
       Команда dynamic_path загружает и добавляет ENGINE из заданного пути.
       Это эквивалентно отправке ctrls SO_PATH с аргументом пути, за которым
       следует LIST_ADD со значением 2 и LOAD, в динамический ENGINE. Если
       это не обязательное поведение, альтернативные ctrls могут быть отправлены
       непосредственно в динамический ENGINE с помощью команд ctrl.

       Команда init определяет, инициализировать ли ENGINE. Если значение
       равно 0, ENGINE не будет инициализирован, если 1 будет сделана попытка
       немедленно инициализировать ENGINE. Если команда init отсутствует,
       тогда будет предпринята попытка инициализировать ENGINE после того,
       как все команды в ее разделе были обработаны.

       Команда default_algorithms устанавливает алгоритмы по умолчанию,
       которые ENGINE будет предоставлять, используя функции
       ENGINE_set_default_string().

       Если имя не соответствует ни одному из приведенных выше имен команд,
       предполагается, что это команда ctrl, которая отправляется в ENGINE.
       Значением команды является аргумент команды ctrl. Если значением
       является строка EMPTY, то никакое значение не отправляется команде.
@display
       Для примера:

        [engine_section]

        # Настройте ENGINE с именем "foo"
        foo = foo_section

        [foo_section]
        # Загрузить движек из DSO
        dynamic_path = /some/path/fooengine.so
        # Специфичный для foo объект ctrl.
        some_ctrl = some_value
        # Еще один ctrl, который не имеет значения.
        other_ctrl = EMPTY
        # Поставьте все алгоритмы по умолчанию
        default_algorithms = ALL
@end display
@item   EVP Configuration Module
       Этот модуль имеет имя alg_section, которое указывает на раздел,
       содержащий команды алгоритма.

       В настоящее время поддерживается только команда алгоритма fips_mode,
       значением которой может быть только отключенная логическая строка.
       Если fips_mode включен, возникает ошибка, так как эта версия
       библиотеки не поддерживает FIPS.

@item   SSL Configuration Module
       Этот модуль имеет имя ssl_conf, которое указывает на раздел, содержащий
       конфигурации SSL.

       Каждая строка в разделе конфигурации SSL содержит название конфигурации
       и раздел, содержащий ее.

       Каждый раздел конфигурации состоит из пар значений команд для SSL_CONF.
       Каждая пара будет передана в структуру SSL_CTX или SSL, если она вызовет
       SSL_CTX_config() или SSL_config() с соответствующим именем конфигурации.

       Примечание: любые символы перед начальной точкой в ​​разделе конфигурации
       игнорируются, поэтому одну и ту же команду можно использовать
       несколько раз.
@display
       Для примера:

        ssl_conf = ssl_sect

        [ssl_sect]

        server = server_section

        [server_section]

        RSA.Certificate = server-rsa.pem
        ECDSA.Certificate = server-ecdsa.pem
        Ciphers = ALL:!RC4
@end display
       Конфигурация системы по умолчанию с именем system_default,
       если она есть, будет применена при любом создании
       структуры SSL_CTX.
@display
       Пример конфигурации с системой по умолчанию:

        ssl_conf = ssl_sect

        [ssl_sect]

        system_default = system_default_sect

        [system_default_sect]

        MinProtocol = TLSv1.2
@end display
@item NOTES
       Если файл конфигурации пытается раскрыть переменную, которая не
       существует, то отмечается ошибка, и файл не загружается. Это может
       произойти, если попытаться расширить несуществующую переменную среды.
       Например, в предыдущей версии OpenSSL в основном файле конфигурации
       OpenSSL по умолчанию использовалось значение HOME, которое не может быть
       определено в системах, отличных от Unix, и может вызвать ошибку.

       Эту проблему можно обойти, включив раздел по умолчанию, чтобы указать
       значение по умолчанию: тогда, если поиск среды не удался, вместо него
       будет использоваться значение по умолчанию. Чтобы это работало правильно,
       значение по умолчанию должно быть определено в файле конфигурации раньше,
       чем в расширении. Смотрите раздел EXAMPLES для примера того, как это сделать.

       Если в том же разделе существует одна и та же переменная, все значения,
       кроме последнего, будут игнорироваться. В определенных обстоятельствах,
       таких как DN, одно и то же поле может встречаться несколько раз. Обычно
       это обходится путем игнорирования любых символов перед начальной '.' как здесь:
@display
        1.OU="My first OU"
        2.OU="My Second OU"
@end display
@item EXAMPLES
       Вот пример файла конфигурации с использованием некоторых из функций,
       упомянутых выше.
@display
        # Это раздел по умолчанию.

        HOME=/temp
        RANDFILE= $@{ENV::HOME@}/.rnd
        configdir=$ENV::HOME/config

        [ section_one ]

        # Мы сейчас в первом разделе.

        # Кавычки допускают пробелы в начале и в конце
        any = " any variable name "

        other = A string that can \
        cover several lines \
        by including \\ characters

        message = Hello World\n

        [ section_two ]

        greeting = $section_one::message
@end display
       В следующем примере показано, как безопасно развернуть переменные среды.

       Предположим, вы хотите, чтобы переменная с именем tmpfile ссылалась
       на временное имя файла. Каталог, в который он помещен, может определяться
       переменными окружения TEMP или TMP, но они могут вообще не иметь никакого
       значения. Если вы просто включите имена переменных среды, а переменная не
       существует, это приведет к ошибке при попытке загрузить файл конфигурации.
       Используя раздел по умолчанию, можно найти оба значения, причем TEMP имеет
       приоритет, а \tmp можно использовать, если не определено ни одно из них:
@display
        TMP=/tmp
        # Вышеуказанное значение используется, если TMP не в среде
        TEMP=$ENV::TMP
        # Вышеуказанное значение используется, если TEMP не в среде
        tmpfile=$@{ENV::TEMP@}/tmp.filename
@end display
       Простой пример конфигурации библиотеки OpenSSL для входа в режим FIPS:
@display
        # Имя приложения по умолчанию: должно соответствовать параметру
        # "appname" (если есть), предоставленному в CONF_modules_load_file
        # и др.
        openssl_conf = openssl_conf_section

        [openssl_conf_section]
        # Список модулей конфигурации
        alg_section = evp_sect

        [evp_sect]
        # Установите "yes" для входа в режим FIPS, если поддерживается
        fips_mode = yes
@end display
       Примечание: в приведенном выше примере вы получите ошибку в
       версиях OpenSSL, не поддерживающих FIPS.

       Более сложная конфигурация библиотеки OpenSSL. Добавьте OID и не
       переходите в режим FIPS:
@display
        # Имя приложения по умолчанию: должно соответствовать параметру
        # "appname" (если есть), предоставленному CONF_modules_load_file
        # и др.
        openssl_conf = openssl_conf_section

        [openssl_conf_section]
        # Список модулей конфигурации
        alg_section = evp_sect
        oid_section = new_oids

        [evp_sect]
        # Это не будет иметь никакого эффекта, так как режим FIPS по умолчанию
        # отключен. Установите "yes" для входа в режим FIPS, если поддерживается
        fips_mode = no

        [new_oids]
        # Новый OID, просто короткое имя
        newoid1 = 1.2.3.4.1
        # Новое имя и полное имя OID
        newoid2 = New OID 2 long name, 1.2.3.4.2
@end display
       Приведенные выше примеры можно использовать с любым приложением,
       поддерживающим конфигурацию библиотеки, если "openssl_conf" изменен
       для соответствия соответствующему "appname".
@display
       Например, если второй пример файла выше сохранен в "example.cnf", то
       командная строка:

        OPENSSL_CONF=example.cnf openssl asn1parse -genstr OID:1.2.3.4.1

       будет выводить:

           0:d=0  hl=2 l=   4 prim: OBJECT            :newoid1

       показывая, что объект OID "newoid1" был добавлен как объект "1.2.3.4.1".
@end display
@item ENVIRONMENT
@table @asis
@item       OPENSSL_CONF
           Путь к файлу конфигурации. Игнорируется в программах set-user-ID и
           set-group-ID.

@item       OPENSSL_ENGINES
           Путь к каталогу движка. Игнорируется в программах set-user-ID и
           set-group-ID.
@end table
@item BUGS
       В настоящее время нет способа включить символы с использованием восьмеричной
       формы \nnn. Все строки имеют нулевое окончание, поэтому нулевые значения не
       могут составлять часть значения.

       Экранирование не совсем правильно: если вы хотите использовать
       последовательности, такие как \n, вы не можете использовать
       экранирование кавычек в той же строке.

       Файлы загружаются за один проход. Это означает, что расширение
       переменной будет работать только в том случае, если указанные выше
       переменные определены в файле ранее.

@item SEE ALSO
       x509(1), req(1), ca(1)

@item COPYRIGHT
       Copyright 2000-2018 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the OpenSSL license (the "License").  You may not use
       this file except in compliance with the License.  You can obtain a copy
       in the file LICENSE in the source distribution or at
       <https://www.openssl.org/source/license.html>.
@end table
1.1.1a                            2018-11-20                         CONFIG(5)
