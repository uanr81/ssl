@node SSL_CONNECT, Инструкция, STOREUTL, Top
@chapter SSL_CONNECT
@table @asis
@item NAME
       SSL_connect - инициировать рукопожатие TLS/SSL с сервером TLS/SSL

@item SYNOPSIS
        #include <openssl/ssl.h>

        int SSL_connect(SSL *ssl);

@item DESCRIPTION
       SSL_connect() инициирует рукопожатие TLS/SSL с сервером. Канал связи уже
       должен быть установлен и назначен для ssl путем установки базового BIO.

@item NOTES
       Поведение SSL_connect() зависит от лежащего в основе BIO.

       Если лежащий в основе BIO является блокирующим, SSL_connect()
       вернется только после того, как рукопожатие закончено или
       произошла ошибка.

       Если базовый BIO является неблокирующим, SSL_connect() также
       вернется, когда базовый BIO не сможет удовлетворить потребности
       SSL_connect() в продолжении рукопожатия, что указывает на
       проблему с помощью возвращаемого значения -1. В этом случае
       вызов SSL_get_error() с возвращаемым значением SSL_connect()
       приведет к SSL_ERROR_WANT_READ или SSL_ERROR_WANT_WRITE. Затем
       вызывающий процесс должен повторить вызов после принятия
       соответствующих действий для удовлетворения потребностей
       SSL_connect(). Действие зависит от лежащего в основе BIO. При
       использовании гнезда non-blocking ничего не нужно делать, но
       можно использовать select() для проверки требуемого условия.
       При использовании буферизации BIO, например пары BIO, данные
       должны быть записаны или извлечены из BIO, прежде чем можно
       будет продолжить.

       Многие системы реализуют алгоритм Nagle по умолчанию, что
       означает, что он будет буферизовать исходящие данные TCP,
       если пакет TCP уже был отправлен, для которого еще не было
       получено никакого соответствующего ACK от партнера. Это
       может повлиять на производительность после успешного
       рукопожатия TLSv1.3 или успешного возобновления рукопожатия
       TLSv1.2 (или ниже), потому что последним партнером, который
       будет общаться в рукопожатии, является клиент. Если клиент
       также первым отправляет данные приложения (что типично для
       многих протоколов), то эти данные могут быть помещены в
       буфер, пока не будет получено ACK для окончательного
       сообщения о рукопожатии.

       Опция сокета TCP_NODELAY часто доступна для отключения
       алгоритма Nagle. Если приложение решает отключить
       алгоритм Nagle, следует рассмотреть возможность его
       повторного включения позже, если это необходимо.
       Вспомогательная функция BIO_set_tcp_ndelay() может
       использоваться для включения или выключения опции
       TCP_NODELAY.

@item RETURN VALUES
       Могут возникнуть следующие возвращаемые значения:
@display
       0   Рукопожатие TLS/SSL не было успешным, но было
           отключено и контролировалось спецификациями протокола
           TLS/SSL. Вызовите SSL_get_error() с возвращаемым
           значением ret, чтобы выяснить причину.

       1   Рукопожатие TLS/SSL было успешно завершено, соединение
           TLS/SSL установлено.

       <0  Рукопожатие TLS/SSL не было успешным, поскольку
           произошла фатальная ошибка на уровне протокола
           или произошла ошибка соединения. Выключение не
           было чистым. Также может возникнуть действие,
           необходимо продолжить операцию для неблокирующего
           BIOs. Вызовите SSL_get_error() с возвращаемым
           значением ret, чтобы выяснить причину.
@end display
@item SEE ALSO
       SSL_get_error(3), SSL_accept(3), SSL_shutdown(3), ssl(7), bio(7),
       SSL_set_connect_state(3), SSL_do_handshake(3), SSL_CTX_new(3)

@item COPYRIGHT
       Copyright 2000-2018 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the OpenSSL license (the "License").  You may not use
       this file except in compliance with the License.  You can obtain a copy
       in the file LICENSE in the source distribution or at
       <https://www.openssl.org/source/license.html>.
@end table
1.1.1a                            2018-11-20                    SSL_CONNECT(3)
