ASN.1 простыми словами
Автор: Строжевский Юрий
Источник: Персональный сайт Юрия Строжевского
Опубликовано: 23.10.2012
Исправлено: 10.12.2016
Версия текста: 1.2
1. Общие правила кодирования ASN.1
2. Кодирование типа REAL
3. Кодирование типа OBJECT IDENTIFIER
4. Кодирование типа INTEGER
5. Кодирование строковых значений
6. Кодирование даты и времени
7. Кодирование последовательностей бит (битовых строк)
8. Кодирование префиксных типов
9. Кодирование типа SEQUENCE
10. Кодирование типа SET
11. Кодирование типа BOOLEAN
	
ASN.1 может быть закодирован множеством способов/кодеков:

BER (Basic Encoding Rules) (Основные правила кодирования)
CER (Canonical Encoding Rules) (Канонические правила кодирования)
DER (Distinguished Encoding Rules) (Различающееся Правила кодирования)
GSER (Generic String Encoding Rules) (Общие правила кодирования строк)
JER (JSON Encoding Rules) (JSON правила кодирования)
LWER (Light Weight Encoding Rules) (Легкий вес Правила кодирования)
OER (Octet Encoding Rules) (Октета Правила кодирования)
PER (Packed Encoding Rules) (Упакованные правила кодирования)
SER (Signalling specific Encoding Rules) (Сигнализации конкретные правила кодирования)
XER (XML Encoding Rules) (XML правила кодирования)

Введение

Уже на протяжении достаточно большого периода времени мне приходится иметь дело с ASN.1. Мне посчастливилось работать как в сфере создания криптографических программ, так и в сфере телекоммуникаций. И в той, и в другой сфере изначально крайне активно и повсеместно используется стандарт ASN.1.

Однако и в процессе создания программ криптографической направленности, и в процессе создания программ для телекоммуникационной отрасли я постоянно встречался с одним и тем же мнением: ASN.1 – это сложный и непонятный формат, а следовательно, для кодирования/декодирования лучше применять сторонние компиляторы (а иногда даже другие стандарты кодирования передаваемой информации).

Одна из причин, по которым сложилась ситуация, когда подавляющее большинство разработчиков программ считают стандарт ASN.1 сложным, это отсутствие книг по данному вопросу. Да, несмотря на почтенный возраст данного стандарта, множество свободно распространяемых компиляторов и различных статей, всё ещё крайне мало книг (или даже статей в Интернете), где бы простым и понятным языком, с большим количеством примеров, прояснялись вопросы кодирования простых типов ASN.1.

Исправляя сложившуюся ситуацию, данная статья отчасти служит неким пособием, помогающим даже не сталкивавшемуся ранее с этим форматом человеку разобраться в тонкостях кодирования ASN.1. Статья охватывает вопросы исключительно только кодирования простых (не составных) типов – REAL, INTEGER, OBJECT IDENTIFIER, все виды строк, BOOLEAN, NULL, SEQUENCE, SET. В статье приводится подробнейшее объяснение всех тонкостей кодирования для каждого из типов, также приводятся подробные примеры, поясняющие тонкости кодирования для данного типа. В отдельном файле, прилагающемся к данной статье, можно найти код на С++, формирующий все примеры из статьи. Кроме того, в этом файле с примерами приводятся дополнительные материалы, не рассмотренные в рамках данной статьи. Все материалы статьи опираются на последний стандарт ASN.1 от 2008 года, все составляющие под-стандарты которого можно скачать одним файлом по ссылке http://www.itu.int/rec/T-REC-X.680-X.693-200811-I/en. Если это специально не оговаривается, то приведенные в статье примеры кодируют типы в стандарте ASN.1 BER (Basic Encoding Rules).

Также упомяну, что буду рад любым (хорошим или критическим) отзывам на эту статью. Отзывы прошу присылать на мою официальную почту yury@strozhevsky.com с пометкой "Статья ASN.1 простыми словами".

В большинстве пособий и книг по ASN.1 изучение кодирования начинается с простейших, не сложных, типов и заканчивается наисложнейшими. В этой статье порядок будет строго противоположный – читателю сначала будет предложено изучить кодирование сложных типов, и только потом постепенно перейдём к изучению простейших. Это позволит однажды усвоив методы кодирования для сложного типа просто и быстро понять методику кодирования более простого.

1. Общие правила кодирования ASN.1

Сначала всё же необходимо пояснить некоторые основы кодирования в формате ASN.1.

Для начала поясню, для чего же создавался этот стандарт. В мире существует множество различных компьютеров. И, кроме того, существует множество стандартов представления данных в этих компьютерах. ASN.1 создавался как некий общий стандарт, позволяющий описывать произвольную информацию, которая бы понималась любым компьютером, имеющим представление об этом стандарте. Поэтому в стандарте ASN.1 оговариваются жесткие правила кодирования даже на уровне отдельных битов информации, а также взаимного их расположения. Дополнительно нужно сказать, что стандарт ASN.1 кодирует информацию не в виде текста, а виде двоичных последовательностей. Сейчас уже появились вариации форматов кодирования, позволяющие представлять данные и в виде текста (XML), но обзор этих форматов выходит за рамки данной статьи. Здесь мы рассмотрим только самое сложное – двоичное кодирование (формат ASN.1 BER – Basic Encoding Rules).

Данные, закодированные в формате ASN.1, представляют собой последовательность байт (или "октетов"), которые идут один за другим, без каких либо разрывов. Последовательность, закодированную в ASN.1, можно передавать по линиям связи, сохранять в файл – блок закодированной информации в ASN.1 уже содержит необходимое описание его общей длины и содержимого.

Для возможности подобного описания содержащейся в закодированном блоке информации применяется определенная общая структура каждого блока. Каждый блок содержит минимум 3 обязательных части (в отдельных случаях остаются только первые два блока, но эти случаи описываются отдельно):

    Часть идентификатора блока (до нескольких октетов).
    Часть общей длины блока (до нескольких октетов).
    Часть, содержащая собственно значение, которое переносит этот блок (до нескольких октетов);

Кроме этого может быть ещё четвертая, не обязательная часть – часть октетов окончания значения блока (несколько октетов). Про эту часть будет рассказано несколько позже.

Перейдём к описанию каждой части ASN.1-кодированного блока.

Часть идентификатора блока состоит минимум из одного октета. Формат этого первого октета строго фиксирован.

    биты 8 и 7 (старшие биты, обычно их записывают крайними слева) кодируют так называемый "класс" текущего блока:
    Биты 8 и 7 равны 002 - класс блока UNIVERSAL;
    Биты 8 и 7 равны 012 - класс блока APPLICATION;
    Биты 8 и 7 равны 102 - класс блока CONTEXT-SPECIFIC;
    Биты 8 и 7 равны 112 - класс блока PRIVATE;
    бит 6 должен быть установлен в 0, если текущий блок содержит информацию только об одном значении, и должен быть установлен в 1, если внутри значения блока содержатся дополнительные ASN.1-кодированные блоки;
    биты с 5 по 1 кодируют собственно идентификатор типа для данного блока;

Если идентификатор типа для блока находится в диапазоне значений 0-30, идентификационный блок состоит только из одного октета. Если же идентификатор типа для блока имеет значение 31 и выше, то в битах 5-1 выставляются все 1, а в последующих октетах кодируется нужный номер. Номер идентификатора типа кодируется как беззнаковое целое, разложенное по основанию 128. В каждом октете, кодирующем идентификатор типа для блока, старший бит должен быть равен 1, кроме самого крайнего, завершающего октета (способ кодирования полностью совпадает со способом, которым кодируются SID для OBJECT IDENTIFIER, см. ниже).

Часть общей длины блока содержит минимум 1 октет, кодирующий длину значения, которое содержит блок (именно только длину блока, содержащего закодированное значение, а не общую длину всего закодированного блока вместе с идентификатором блока и частью общей длины!). Длина блока в простейшем случае кодируется как беззнаковое целое, разложенное по основанию 128. Бит 8 (старший бит) в этом случае является дополнительным флагом. Если общая длина закодированного блока превышает 128, то старший бит первого октета части общей длины блока должен быть установлен в 1, а следующие 7 бит должны кодировать беззнаковое целое значение количества последующих октетов, которые и будут кодировать реальную общую длину блока.

Например, если общая длина блока равна L = 201, то она будет кодироваться с помощью двух октетов:

1000 0001 (81)

1100 1001 (C9)

Кроме явного задания общей длины блока можно определять окончание данного блока непосредственно в процессе декодирования блока. Это важно, когда при начальном кодировании блока не ясно, сколько именно октетов он будет содержать (потоковое кодирование). В этом случае первый октет части общей длины блока должен быть равен 80 (старший бит 8 равен 1, и все остальные биты равны 0). Окончание всего блока определяется по наличию в блоке значения двух последовательно идущих октетов 00 00.

2. Кодирование типа REAL

Общее описание типа:

    Класс тега - UNIVERSAL (00);
    Номер тега - 9;
    Форма кодирования значения – примитивная (не конструктивная форма);

Для начала немного теории, касающейся собственно чисел с плавающей запятой. Числа с плавающей запятой обычно представляют состоящими из трёх частей: мантиссы, основания и экспоненты. Более просто это можно объяснить с помощью формулы: REAL = (мантисса)*(основание)(экспонента). Если по этой формуле представлять обычные десятичные числа, то получится REAL = (мантисса)*10(экспонента). Так как в ASN.1 и мантисса, и экспонента могут быть как положительными, так и отрицательными, то возможно представление сколь угодно больших и сколь угодно маленьких значений, с произвольным знаком.

В отличие от обычного, машинного, представления чисел с плавающей запятой (IEEE 754), в ASN.1 тип REAL практически не ограничен как по размеру мантиссы (мантисса может состоять из практически не ограниченного числа октетов и представлять сколь угодно большое число), так и по размеру экспоненты (значение экспоненты также может состоять из произвольного количества октетов). Ограничения при кодировании накладываются только на значение "основания": в качестве "основания" могут быть выбраны только числа 10, 2, 8 или 16.

Для кодирования типа REAL применяются следующие три основных блока:

    Служебный информационный октет.
    Значение экспоненты числа.
    Значение мантиссы числа.

В служебном информационном октете содержится следующая информация:

- Возможные комбинации битов 8 и 7 (крайние слева):

    Бит 8 = 1 – применяется двоичное кодирование (по одному из оснований 2, 8 или 16);
    Бит 8 = 0 и бит 7 = 0 – применяется десятичное кодирование (фактически кодирование строкового стандартного представления числа, см. далее);
    Бит 8 = 0 и бит 7 = 1 – закодированное значение является "специальным значением" (NaN, INFINITE etc.), или закодированное значение кодирует "-0";

- Бит 7 установлен в 0, когда кодируемое число положительно, и установлен в 1, когда кодируемое число отрицательно;

- Комбинация битов 6 и 5 определяет базу двоичного кодирования:

    00 - кодируемое число разложено по основанию 2;
    01 - кодируемое число разложено по основанию 8;
    10 - кодируемое число разложено по основанию 16;
    11 - зарезервировано для будущих возможных изменений;

- Биты 4 и 3 кодируют значение "scaling factor" (F, см. далее) в двоичном коде;

- Биты 2 и 1 кодируют формат представления экспоненты в закодированном числе:

    00 - следующий октет представляет собой единственный октет, кодирующий значение экспоненты;
    01 - следующие два октета кодируют значение экспоненты;
    10 - следующие три октета кодируют значение экспоненты;
    11 - следующий октет содержит количество последующих октетов, кодирующих значение экспоненты (количество октетов кодируется как обычное число без знака (допускаются только положительные значения, естественно), а последующие октеты кодируют значение экспоненты;

Значение экспоненты числа кодируется целым числом, состоящим из произвольного количества октетов. Здесь необходимо сделать маленькое отступление и рассказать, как именно в ASN.1 кодируются как положительные целые числа, так и отрицательные.

Положительные целые числа в ASN.1 представляют собой последовательность "индексов" при соответствующих степенях разложения по основанию 256. То есть целое число, представленное в обычном десятичном формате, сначала раскладывается по основанию 256, а потом индексы при соответствующих степенях 256 записываются в качестве кодирующих октетов. Для наглядного примера возьмём число 32639. Данное число разлагается по основанию 256 как: 3263910 = 127*2561 + 127*2560. Следовательно, коэффициенты при соответствующих степенях 256 будут равны (127, 127). Представляя десятичное значение 127 в виде последовательности битов, получаем: 127 = 0111 1111, или, представляя каждую группу из четырех битов в качестве числа от 0 до F, получаем: ( 127 )10 = ( 0111 1111 )2 = 7F256. Таким образом, начальное число 32639 будет кодироваться последовательностью из двух октетов ( 7F 7F )256.

Рассмотренным выше способом можно закодировать сколь угодно большое целое положительное число. Однако как быть с кодированием отрицательных целых значений? Именно для кодирования отрицательных целых применяется специальная процедура кодирования значений.

Для примера опять возьмем число 32639, но теперь пусть оно будет отрицательным (-32639). Кодирование отрицательных целых построено так, что на самом деле кодируется не одно, а два целых значения – одно основное значение и другое целое значение, которое нужно вычесть из основного значения. То есть при декодировании для получения закодированного отрицательного числа просто вычислить результат (x - y). Как видно из этой простейшей формулы, если значение "x" меньше, чем значение "y", то результат будет меньше нуля (то есть отрицательное число).

Вышеупомянутые два числа (основное число и число, которое надо вычесть из основного) формируются по следующим правилам:

    Пусть закодированное в ASN.1 число состоит из последовательности из N бит.
    Тогда число, которое надо вычесть из основного числа, образуется как число также состоящее из N бит, но где все биты, кроме самого старшего (крайний левый бит), установлены в 0.
    Основное число также состоит из N бит, но в нем самый старший бит установлен в 0. Значения всех остальных битов полностью соответствуют соответствующим битам из изначально закодированного числа (остаются неизменными).

Перейдём к кодированию конкретного числа из примера (-32639). Так как число, которое надо вычесть из основного, должно быть больше основного числа, то кодирование отрицательных целых чисел начинается именно с выбора этого вычитаемого. Так как по правилам это вычитаемое должно разлагаться по основанию 256 так, чтобы все биты, кроме первого, представляющие индексы при соответствующих степенях 256, были равны 0, то ряд возможных вычитаемых представляет собой лидирующий октет 80 (1000 0000) и какое-то количество октетов 00, следующих за ним. То есть в качестве вычитаемых могут использоваться: 80256 (12810), ( 80 00 )256 (3276810), ( 80 00 00 )256 (838860810) и т.п. Для кодирования нашего числа "-32639" выберем первое подходящее вычитаемое, большее кодируемого числа по модулю (то есть большее, чем число 32639). Ближайшее такое число равно 32768 (80 00256).

Теперь необходимо получить значение основного числа. Для этого надо опять решить простейшую формулу: x - 32768 = -32629. Решая уравнение, получаем значение x = 129 = 129*2560, следовательно, число 129 кодируется одним байтом 81256. Если более внимательно рассматривать правила, то можно понять, что количество бит в основном и вычитаемом числах должно быть равно. Количество бит в вычитаемом равно 16. В то же время количество бит в основном числе равно всего 8. Для увеличения числа бит в основном числе просто добавим не значащие нули для старших бит. Тогда получим 129 = 0*2561 + 129*2560, а следовательно, основное число будет кодироваться двумя октетами как (00 81)256. Теперь, устанавливая первый бит в 1, для полученного двухоктетного основного числа получаем окончательное число, которое кодирует "-32639". Это число будет кодироваться двумя октетами ( 80 81 )256. Ещё раз – основное число образуется из всех битов закодированного числа, кроме самого старшего бита (получаем, что основное число у нас кодируется ( 00 81 )256 ), а вычитаемое число образуется только из одного первого бита, установленного в 1, и всех остальных битов, установленных в 0 (получаем, что вычитаемое число у нас кодируется как ( 80 00 )256 ).

А теперь приятная информация – в современных компьютерных системах целые числа (как положительные, так и отрицательные) автоматически кодируются и хранятся именно в том формате, который и был описан выше. То есть для кодирования целых чисел в ASN.1 не нужно выполнять вообще никаких действий – просто нужно сохранить их байт за байтом и всё.

Значение мантиссы числа представляет собой всегда беззнаковое целое. То есть мантисса числа, кодированного в ASN.1, всегда является положительным числом. Чтобы кодировать отрицательные числа с плавающей точкой, в ASN.1 предусмотрен отдельный бит (бит 7) в служебном октете (см. выше).

Мантисса кодируется как последовательность байтов, представляющих собой коэффициенты разложения начального числа по основанию 256. То есть если мантисса числа в десятичном виде равна 32639, значит, закодированное число будет состоять из двух октетов 7F 7F (3263910 = 127*2561 + 127*2560 = 7F*FF1 + 7F*FF0).

Примеры кодирования чисел REAL в ASN.1 в двоичном представлении:

Для примера возьмём число 0.15625. Для начала закодируем его в двоичном представлении по основанию 2. Коэффициенты разложения этого числа по основанию 2 будут находиться как: 0.1562510 = 1*2-3 + 1*2-5. То есть мантисса для нашего тестового числа будет иметь значение М = 1012, а значение экспоненты будет равно -5. Служебный октет для этого числа будет 1000 00002 = 80256. Значение экспоненты будет кодироваться одним октетом: -5 = 123 - 128 и, следовательно, основное число будет равно 12310 = 7B256, а вычитаемое число равно 12810 = 80256. Тогда окончательный октет, кодирующий число -5, будет равен FB256. Значение мантиссы также кодируется одним октетом: 1012 = 05256. Теперь нам известны все части блока, кодирующего значение 0.15625 в двоичном коде по основанию 2, и весь кодирующий блок будет состоять из трёх октетов (80 FB 05)256.

Теперь закодируем это же число 0.15625, но уже по основанию 8. Коэффициенты разложения этого числа по основанию 8 будут находиться как: 0.1562510 = 1*8-1 + 2*8-2. То есть мантисса для нашего тестового числа будет иметь значение М = 128 = (001 010)2 (при кодировании числа в восьмеричной системе для каждого значения требуется три отдельных бита). Значение экспоненты будет равно -2. Служебный октет для этого числа будет 1001 00002 = 90256. Значение экспоненты будет кодироваться одним октетом, где основное и вычитаемое число находятся из формулы: -2 = 126 - 128. Следовательно, октет, кодирующий значение экспоненты -2, будет FE256. Значение мантиссы числа будет также кодироваться одним октетом 0A256.

В этом примере разложим число 0.15625 по основанию 16. Коэффициенты этого разложения будут находится как: 0.1562610 = 2*16-1 + 8*16-2. Следовательно получаем выражение для мантиссы М = 2816 = (0010 1000)2 и значение экспоненты Е = -2. Теперь поставим дополнительное условие: значение мантиссы должно быть "нормализовано", то есть не должно содержать нулей в младших разрядах числа (также это требование зачастую звучит как "мантисса должна быть нечетной", так как если крайний младший бит равен 1, то всё число получается нечетным ввиду того, что к степеням двойки добавляется 1*20). Как может быть выполнено подобное условие "нормализации"? Очевидно, что основной способ – изменение значения экспоненты числа, сдвигающее плавающую точку. В случае использования разложения по основанию 2 всё представляется простым - изменение значения экспоненты на 1 сдвигает плавающую точку (или добавляет/удаляет нули в младших разрядах мантиссы) ровно на одну позицию. Однако в случае использования разложения по основаниям 8 и 16 получаем, что изменение значения экспоненты на 1 сдвигает плавающую точку в мантиссе сразу на 3 и 4 бита соответственно (так как в случае разложения по основанию 8 для представления числа требуется 3 бита, а в случае разложения по основанию 16 для представления числа требуется 4 бита). Следовательно, далеко не всегда полученное для разложения по основаниям 8 и 16 значение мантиссы может быть "нормализовано" просто изменением значения экспоненты. Для более "тонкой настройки" возможности сдвига плавающей точки в мантиссе был введен дополнительный множитель: умножающий фактор, F. Умножающий фактор сдвигает плавающую точку в мантиссе вправо (или добавляет необходимое количество нулевых битов справа от числа). Для этого перед декодированием значение мантиссы получается как результат умножения M = N * 2F. Общеизвестно, что умножение целого числа на 2 равноценно битовому сдвигу влево на 1 бит. Соответственно, умножение на 2F равноценно битовому сдвигу влево на F бит. Таким образом, получаем следующий процесс кодирования/декодирования мантиссы при предъявлении требования её нормализации:

    Пусть дана мантисса 0010 1000.
    При кодировании "нормализуем" её (или сдвигаем вправо на 3 бита), получая 0000 0101, одновременно устанавливая значение умножающего фактора F = 3.
    При декодировании умножаем закодированное значение мантиссы на 2F, чем сдвигаем закодированную мантиссу обратно на F = 3 бита влево.

Следовательно, все число с плавающей точкой из нашего примера (при условии "нормализации" мантиссы) будет кодироваться следующей последовательностью октетов:

( AC FE 05 )256

Кроме кодирования всех частей числа с плавающей точкой в виде двоичного представления в разложении по различным степеням двойки, дополнительно есть прекрасная возможность представлять подобные числа в ASN.1 в обычном строковом виде, в каком мы обычно и видим такие числа. В этом случае считается, что число кодируется с основанием 10.

При кодировании по основанию 10 дополнительно вводится понятие "форм представления числа". Всего таких форм 3 (формы NR1, NR2 и NR3), и описываются они в отдельном стандарте ISO 6093. Так как этот стандарт является платным, то для ознакомления с формами представления чисел можно порекомендовать "предка" ISO 6093 - стандарт ECMA-63, который легко может быть найден в Интернете.

При кодировании числа с плавающей точкой в представлении разложения по основанию 10 в служебном информационном октете указывается код формы представления числа (01, 02 или 03 для соответствующих форм), а сразу после служебного информационного октета указываются коды символов, представляющих кодированное число. Разрешены следующие коды символов:

    Символы, обозначающие цифры 0-9 (коды 30256 - 39256 соответственно).
    Пробел (код 20256).
    Разделительный символ "." (код 2E256).
    Разделительный символ "," (код 2C256).
    Символ представление экспоненты "E" (код 45256), либо тот же символ представления экспоненты, но в виде "e" (код 65256).
    Символ "-" (код 2D256).
    Символ "+" (код 2B256)..

Все остальные символы запрещены к кодированию (при декодировании символов, отличных от приведенных выше, декодер ASN.1 обязан выдать ошибку).

Примеры кодирования числа с плавающей точкой в десятичной форме:

Для примера закодируем обычное число 1. В случае представления в форме NR1 число будет кодироваться строкой "1" (или "+1"). В случае представления числа в форме NR2 число уже должно быть закодировано с указанием разделительного символа, поэтому все представленные ниже строки равноценны:

    "1,"
    "+1.0"
    "1,000000"
    " 1.0" (в начале строки может присутствовать неограниченное количество пробелов)

Теперь представим 1 в форме NR3. Здесь уже обязательно применение как разделительного символа, так и символа экспоненты.

Кроме обычных чисел ASN.1, позволяет кодировать также и ряд "специальных" чисел:

    PLUS-INFINITY (плюс бесконечность);
    MINUS-INFINITY (минус бесконечность);
    NOT-A-NUMBER (так называемое "не-число");
    minus zero (для возможности кодирования "-0");

Все специальные числа кодируются только одним служебным информационным октетом, без указания октетов для экспоненты и мантиссы:

    PLUS-INFINITY - 40256;
    MINUS-INFINITY - 41256;
    NOT-A-NUMBER - 42256;
    minus zero - 43256;

3. Кодирование типа OBJECT IDENTIFIER

Общее описание типа:

    Класс тега – UNIVERSAL (00);
    Номер тега – 6;
    Форма кодирования значения – примитивная (не конструктивная форма);

Сам по себе OBJECT IDENTIFIER представляет собой последовательность целых беззнаковых чисел. В стандартном представлении для OBJECT IDENTIFIER элементы этой последовательности представляются в виде строки, разделённой знаками ".". Примеры возможных OBJECT IDENTIFIER: 0.1.1, 1.1.1, 2.1234.1234.1234.1234.

Кодирование OBJECT IDENTIFIER (OID) состоит из последовательного кодирования всех составляющих данный OID беззнаковых целых (SID – sub identifier).

Для уменьшения общего размера закодированного OID к первым двум SID применяются следующие правила:

- Первое беззнаковое целое (SID1) должно быть или 0, или 1, или 2. Другие значения недопустимы. SID1 исключается из процесса кодирования, вместо этого значение SID1 вычисляется естественным путём при декодировании SID2 (см. ниже).

- Перед кодированием второго SID к нему применяется следующая формула: SID2 = SID1*40 + SID2.

- Для гарантированного определения SID1 из результата полученного выражения для SID2 к SID2 предъявляются следующие требования:

    Если SID1 = 0 или SID1 = 1 то значение SID2 должно лежать в диапазоне от 0 (включительно) до 39 (включительно);
    Если SID1 = 2, то SID2 может выражаться произвольным целым беззнаковым числом;

- Примеры кодирования первых двух октетов:

    "0.39" кодируется одним целым числом 0*40 + 39 = 39;
    "1.0" кодируется одним целым числом 1*40 + 0 = 40;
    "1.39" кодируется одним целым числом 1*40 + 39 = 79;
    "2.0" кодируется одним целым числом 2*40 + 0 = 80;
    "2.39" кодируется одним целым числом 2*40 + 39 = 119;
    "2.339" кодируется одним целым числом 2*40 + 339 = 419;

Каждый SID кодируется независимо от остальных. Все SID кодируются друг за другом без дополнительных разделителей. Правила кодирования SID одинаковы для всех SID кроме первых двух (см. выше).

Нужно отметить, что теоретически каждый SID может иметь сколько угодно большое целое значение. Следовательно, каждый отдельный SID может кодироваться произвольным, сколь угодно большим, количеством октетов. Обычно для кодирования переменного количества октетов применяется дополнительное кодирование количества этих октетов (перед последовательностью закодированных октетов кодируется октет, содержащий количество закодированных октетов). Однако в случае кодирования SID применяется другой подход – самый старший бит каждого из октетов, кодирующих отдельный SID, является своеобразным флагом, по которому можно судить, последний это октет для данного SID или нет. То есть, так как один SID может быть закодирован с помощью более чем одного октета (в случае большого целого числа), то применяется следующее правило: во всех октетах, кодирующих значение SID, кроме последнего (младшего) октета, значение самого старшего бита должно быть установлено в 1. Таким образом, получается, что значащими для кодирования SID битами в 8-битовом октете являются только младшие 7 бит, старший бит в каждом октете используется как флаг, указывающий на последний октет. В связи с этим перед кодированием каждый SID переводится из десятичной формы в форму разложения по основанию 128 (группируется по 7 бит).

Примеры кодирования SID:

    SID = 64310 = 5*1281 + 3*1280 = ( 05 03 )128. Так как все октеты, кроме самого младшего, должны иметь установленный старший бит, то SID равный 643 кодируется в ASN.1 с помощью двух октетов ( 85 03 )256.
    SID = 11354910 = 6*1282 + 119*1281 + 13*1280 = ( 06 77 0D )128. Так как все октеты, кроме самого младшего, должны иметь установленный старший бит, то SID равный 113549 кодируется в ASN.1 с помощью трех октетов ( 86 F7 0D )256.
    SID = 4915210 = 3*1282. В этом случае в разложении отсутствуют младшие степени числа 128. Но так как при кодировании SID нигде не сохраняется значение экспоненты числа, то для нужд кодирования 49152 должно представляться в виде ( 3*1282 + 0*1281 + 0*1280 ) = ( 03 00 00 )128 (то есть закодированное число должно всегда состоять из числа октетов, больших на 1 старшей степени числа 128 при разложении). Так как все октеты, кроме самого младшего, должны иметь установленный старший бит, то SID равный 49152 кодируется в ASN.1 с помощью трех октетов ( 83 80 00 )256.

При кодировании SID должно использоваться минимальное количество октетов. То есть SID = 643 не должен быть представлен как ( 0*1282 + 5*1281 + 3*1280 ) = ( 00 05 03 )256 и, следовательно, не должен быть закодирован как ( 80 85 03 )256. Простейшая проверка на правильность кодирования SID – первый октет закодированного SID не должен быть равен 80256.
4. Кодирование типа INTEGER

Общее описание типа:

    Класс тега - UNIVERSAL (00).
    Номер тега – 2.
    Форма кодирования значения – примитивная (не конструктивная форма).

Вопросы кодирования целых (INTEGER) уже рассматривался ранее (в разделе, посвященном кодированию типа REAL). Однако еще раз напомню основные особенности этого кодирования.

В ASN.1 могут быть закодированы как положительные, так и отрицательные числа. Каждое целое число практически не ограничено в своей величине (то есть в ASN.1 могут быть закодированы сколь угодно большие (по модулю) целые числа).

Каждое целое число кодируется последовательностью октетов, каждый октет представляет собой 8 бит информации. Каждый октет представляет собой "вес" перед соответствующей степенью числа 256, участвующий в разложении кодируемого числа по основанию 256. То есть для кодирования числа исходное число сначала разлагается по основанию 256, и затем значения "весов" перед соответствующими степенями 256 кодируются в качестве октетов. Например, число 8388607 будет кодироваться по следующей схеме:

    Разложим число по основанию 256: 838860710 = 127*2562 + 255*2561 + 255*2560;
    Получаем, что "веса" при соответствующих степенях 256 будут: 127, 255 и 255;
    Переводим каждое число в последовательность бит, а затем кодируем эту последовательность бит, группируя в группы по 4 бита. Получаем следующие значения для "весов": 7F FF FF;

Кодирование отрицательных целых значений осуществляется по отдельным правилам. Фактически в закодированном отрицательном целом хранится не одно, а два целых числа: основное число и число, которое нужно вычесть из основного числа, чтобы при декодировании получить изначально закодированное отрицательное число. То есть при декодировании изначальное отрицательное число получается по формуле: N = X - Y, где X - основное число, а Y – вычитаемое число. Нетрудно понять, что для того, чтобы N получилось отрицательным, необходимо чтобы выполнялось условие Y > X.

Подробные правила формирования как основного, так и вычитаемого числа уже были описаны ранее, поэтому отсылаю читателя к разделу о кодировании типа REAL.

Примеры кодирования целых чисел:

    80 = 128*2560 = 12810 = (1000 0000)2. Здесь основное число образуется битами 1-7 (младшими, крайними справа) и равно 0, вычитаемое образуется путём маскирования всех битов, кроме старшего и равно ( 1000 0000)2 = 0x80256 = 12810. Следовательно, закодированное число равно 0 - 128 = -128.
    Кодирование положительного значения +128 осуществляется с помощью последовательность октетов 0*2561 + 128*2560 = ( 00 80 )256,то есть добавляется старший нулевой октет. Фактически здесь тоже можно вычислить как основное число, так и вычитаемое число: основное число будет равно 128, а вычитаемое будет равно 0.
    Закодируем число -13610. Число 13610 = 88256 = ( 1000 1000 )2. Так как в этом числе уже установлен старший бит, то для правильного кодирования вычитаемое число должно быть образовано двумя октетами и быть равным (80 00)256 = 128*2561 + 0*2560 = 3276810. Следовательно, основное число при кодировании (-136) может быть получено после решения следующего уравнения: х - 32768 = -136. То есть получаем значение "х" равным 32626 = 127*2561 + 120*2560 = ( 7F 78 )256. Устанавливая для этого числа старший бит, получаем, что окончательное кодирование для числа (-136) будет осуществляться двумя октетами ( FF 78 )256;
    Закодируем число (-8388607). Число 838860710 = 127*2562 + 255*2561 + 255*2560= ( 7F FF FF )256. Так как здесь не установлен старший бит, то вычитаемое число будет равно ( 80 00 00 )256 = 128*2562 + 0*2561 + 0*2560 = 838860810. Следовательно, основное число может быть получено в результате решения уравнения: х - 8388608 = -8388607. То есть получаем х = 1, и, вроде бы, это число раскладывается по основанию 256 просто в 0x01. Однако нам необходимо, чтобы вычитаемое число было (80 00 00)256, а следовательно, основное число должно выражаться в виде (00 00 01)256. Устанавливая первый бит основного числа, получаем, что окончательное кодирование для числа (-8388607) осуществляется тремя октетами (80 00 01)256;

Фактически к кодируемому целому числу предъявляется требование: старшие 9 бит закодированного числа не должны все быть равны 1, и не должны все быть равны 0 (старшие 9 бит закодированного числа не должны быть равны между собой). Если первые 9 бит закодированного числа равны 0, значит, без ущерба для закодированного значения старший октет (старшие 8 бит) можно отбросить (при декодировании он бы просто добавил слагаемое 0*256n, что никак не повлияет на значение числа). Если же старшие 9 бит закодированного числа равны 1, то закодированное число отрицательное и может быть перекодировано с применением меньшего числа октетов (при кодировании были добавлены лишние нулевые октеты в вычитаемое число).

Пример добавления лишних нулевых октетов в вычитаемое число. Возьмем для кодирования число (-128). Положим, вычитаемое число будет равно: (80 00)256 = 3276810, и основное значение вычисляется после решения уравнения ( x - 32768 ) = -128. Следовательно, x = 3264010 = ( 7F 80 )256. Устанавливая старший бит, получаем окончательное кодирование (FF 0x80)256 (здесь равны между собой 9 старших бит). Но ранее мы уже кодировали число (-128) и знаем, что кодирование этого числа в ASN.1 может быть представлено в более короткой форме – в виде только одного октета (80)256.

Ну и ещё раз напомним, что в современных компьютерных системах кодирование целых чисел уже (автоматически) осуществляется по выше описанным правилам. Правда, с одной оговоркой: для кодирования отрицательных чисел все-таки применяется "добавление лишних нулевых октетов в вычитаемое число" (см. предыдущий параграф). То есть, если количество октетов (байт) для хранения целого числа составляет 4, то число (-128) будет закодировано в виде FF FF FF 80 (то есть при кодировании было применено "вычитаемое число" равное (80 00 00 00)256 = 2147483648).
5. Кодирование строковых значений

В ASN.1 существует достаточно широкий выбор строковых типов. Вот их полный перечень:

    NumericString;
    PrintableString;
    TeletextString (тип полностью совпадает с T61String);
    VideotexString;
    VisibleString;
    IA5String;
    GraphicString;
    GeneralString;
    UniversalString;
    BMPString;
    UTF8String;

Некоторые из них уже являются устаревшими (например VideotexString). Каждый тип строк описывает некий набор символов, которые можно применять в строках с данным типом. Дополнительно в используемых строках могут применяться так называемые "управляющие последовательности", позволяющие автоматически настраивать обработку отдельно выделенной строки на поддерживающих эту возможность терминалах. Тот, кто программировал на С\С++, наверняка часто использовал "управляющую последовательность" \n - перевод строки. На самом деле управляющих последовательностей очень много уже в стандарте, кроме того, можно создавать собственные управляющие последовательности, которые будут обрабатываться только на специализированных терминалах (например, переключать цвет выделенных строк на красный, подчеркивать строки и т.п.).

Наиболее продвинутыми и современными форматами являются форматы строк, основанные на стандарте Unicode. Основу стандарта составляет документ ISO 10646.

Тип UniversalString (класс тега UNIVERSAL, номер тега 28, форма кодирования – примитивная). Кодирует Unicode строки, где каждый символ кодируется 4 байтами (октетами).

Тип BMPString (класс тега UNIVERSAL, номер тега 30, форма кодирования – примитивная). Подмножество символов Unicode, каждый символ кодируется всегда 2 байтами (октетами).

Тип UTF8String (класс тега UNIVERSAL, номер тега 12, форма кодирования – примитивная). Представление символов Unicode, но с дополнительной обработкой, позволяющей кодировать каждый символ в последовательность байт переменной длины (от 1 до 7 байт).
6. Кодирование даты и времени

Все типы, описывающие дату и время в ASN.1, являются обыкновенными UTF-8-строками, где значения для года, месяца и так далее кодируется в определенном формате. Форматы для представления каждого типа описываются в свободно доступном стандарте ISO 8601.

Тип UTCTime. Простейший временной тип. Может кодировать только дату и UTC (Universal Coordinated Time) время. Формат строки, кодирующей UTCTime, может иметь либо вид YYMMDDHHMMSSZ (где YY – две последние цифры года, MM – две цифры месяца, DD – две цифры дня, HH – две цифры часа (формат 24-часовой), MM – две цифры минут, SS – две цифры секунд), либо может также кодировать UTC-время вместе с относительным смещением для соответствующего часового пояса в виде YYMMDDHHMMSS+hhmm (или YYMMDDHHMMSS-hhmm).

Тип GeneralizedTime. Расширение типа UTCTime, использующее уже 4 цифры для обозначения года, плюс тип GeneralizedTime позволяет использовать дробные значения для любой из временных составляющих (часа, минуты или секунды). Соответственно форматы могут быть следующими:

    YYYYMMDDHHMMSSZ;
    YYYYMMDDHHMMSS+hhmm;
    YYYYMMDDHHMMSS-hhmm;
    YYYYMMDDHHMMSS.nn (количество знаков после точки не ограничено);
    YYYYMMDDHHMM.nn (количество знаков после точки не ограничено);
    YYYYMMDDHH.nn (количество знаков после точки не ограничено);

Все описанные ниже типы являются новыми для последней версии стандарта X.680:2008.

Тип TIME. Описывает только время в формате HH:MM::SS, либо в формате HHMMSS.

Тип TIME-OF-DAY. То же самое, что и тип TIME, за исключением того, что формат может быть только HHMMSS.

Тип DATE. Описывает только дату в формате YYYYMMDD.

Тип DATE-TIME. Описывает как дату, так и время для этой даты. Формат представления YYYYMMDDHHMMSS. Если значение крайних фракций времени равно 0 (то есть например 0 секунд), то нулевое значение может быть исключено (строка сокращена).

Тип DURATION. Описывает разность между двумя временными промежутками. Формат представления nnYnnMnnDTnnHnnMnnS.
7. Кодирование последовательностей бит (битовых строк)

В разряд типов, кодирующих битовые строки, я отношу два типа – BIT STRING и OCTET STRING.

Тип BIT STRING предназначен для хранения последовательностей наименьших блоков информации – битов. Фактически никакого кодирования не происходит . В блок значения для закодированного значения помещается блок кодируемого значения. За одним только исключением – в первом октете закодированного значения хранится число не используемых бит. Значения количества не используемых бит может изменяться от 0 до 7. Не используемые биты располагаются в битовой строке крайними справа. То есть если закодирована последовательность бит 0000 1111 = 0F, и число не используемых бит равно 4, то при декодировании эту битовую строку следует трактовать как 0000.

При кодировании типа BIT STRING может быть использован как примитивный метод кодирования, так и конструктивный. Конструктивный метод кодирования битовых строк позволяет просто логически разбить одну битовую строку на множество более мелких. При декодировании такой битовой строки, закодированной конструктивным методом, значения из всех вложенных битовых строк объединяются в одну большую битовую строку. В случае использования конструктивного метода задания битовых строк в блоке значения должны быть закодированы только битовые строки, причём у всех битовых подстрок, кроме последней, октет со значением не используемых бит должен быть равен нулю.

Приведем пример конструктивного кодирования битовых строк. Допустим, начальная битовая строка содержит значения 0B 0B 0F, причем количество не используемых бит равно 4. Теперь разобьем эту строку на 3 вложенных битовых подстроки и получим следующую последовательность октетов, кодирующую начальную битовую строку в конструктивной форме:

23 0C

03 02 00 0B

03 02 00 0B

03 02 04 0F

Здесь в первых двух октетах приведены идентификационный октет для конструктивной формы кодирования битовой строки и общая длина значения конструктивной формы (12). Далее задано кодирование битовой строки со значением 0B (количество не используемых бит равно нулю!). Потом еще раз закодирована битовая строка со значением 0B (опять обязательно количество не используемых бит должно быть равно нулю). Последней закодирована битовая строка 0F, у которой задано количество не используемых бит равное 4. Таким образом, соединяя последовательно закодированные битовые подстроки, получим изначально закодированную битовую строку 0B 0B 0 (4 последних бита не используется, а следовательно, F = 1111 отсекается от окончательного значения).

Тип OCTET STRING предназначен для хранения простых последовательностей байт (октетов). То есть в этот тип можно закодировать всё что угодно! То есть в этом типе можно кодировать даже содержимое файлов операционной системы. Одно "но": в случае использования "не явного задания длины" (см. главу про основы кодирования в ASN.1) для типа OCTET STRING следует самостоятельно отслеживать появление в кодируемом потоке двух нулевых октетов подряд (00 00) и создавать дополнительные вложенные подстроки, разделяющие нулевые октеты во входном потоке октетов.
8. Кодирование префиксных типов

Зачастую необходимо различать закодированные в одном элементы одного и того же типа, следующие один за другим (например при кодировании типа SET, где порядок вложенных элементов может быть произвольным). Для этого применяют дополнительное кодирование элементов в блоках с новыми, специфичными тегами. Например, типа REAL имеет класс тега UNIVERSAL (00) и номер тега 9. Чтобы логически отличить два подряд идущих значения REAL применяют дополнительное, "обёрточное" кодирование значения. Для этого используют классы тегов кроме класса UNIVERSAL (00). То есть вводят новый тип, со своим отличительным номером тега и классом тега, отличным от UNIVERSAL (00), а в качестве значения для этого нового типа кодируется весь стандартный блок закодированного типа REAL (новый тип "инкапсулирует" всё закодированное значение другого типа, вместе с блоками идентификационного октета и блоками длины).

Например "обернем" так закодированное значение для типа REAL для значения 0.15625 (кодированное в двоичной форме, основание равно 2, см. главу про кодирование REAL). Полностью это значение кодируется пятью октетами 09 03 80 FB 05. Для внешней "обертки" используем класс тега PRIVATE (11) и номер тега выберем равный 2. Так как в качестве значения для внутреннего блока будет использоваться не примитивный тип, а закодированное стандартное значение для типа REAL, то внешняя "обертка" будет иметь конструктивную форму кодирования. Следовательно полностью тип REAL вместе с "оберткой" будет кодироваться с помощью октетов E2 05 09 03 80 FB 05.

В случае, когда между получателем закодированной информации и отправителем существует заранее согласованная и известная схема ASN.1-сообщений, то при использовании "оберточного кодирования" можно не указывать значение информационного октета для внутреннего, "обёрнутого", значения. В этом случае в качестве значения для "обёртки" будет уже использоваться примитивный тип, и закодированное значение можно записать как C2 03 80 FB 05 (здесь C2 – указание на применение класса тега PRIVATE + применение примитивной формы кодирования + номер тега равен 2; 03 – длина блока значения; оставшиеся октеты – блок значения, непосредственно взятый из блока значения для стандартного кодирования типа REAL). Таким образом, можно сказать, что использование заранее согласованных схем ASN.1 позволяет кодировать в выбранных местах общего ASN.1-сообщения выбранные типы с помощью выбранных значений как классов тегов, так и номеров классов тегов (полная свобода действий!).

В заключение скажу несколько слов о нотации, которой обозначаются "префиксные типы". Рассмотрим несколько примеров:

Type1 ::= [0] BOOLEAN

Здесь описывается Type1, который имеет класс тега "Context-specific" (10)2, номер тега равный 0 и конструктивную форму кодирования. В блоке значения для Type1 передается полностью кодированное значение стандартного типа BOOLEAN.

Type2 ::= [PRIVATE 2] IMPLICIT BOOLEAN

Здесь описывается тип Type2, который имеет класс тега "Private" (11)2, номер тега равный 2 и примитивную форму кодирования. То есть в блоке значения для Type2 передается только соответствующий блок значения из стандартно закодированного типа BOOLEAN (идентификационный блок и блок длины теперь берутся из Type2).

То есть по умолчанию в ASN.1 в качестве класса тега применяется "Context-specific" (10)2, а также применяется конструктивная форма кодирования. То есть первый пример может быть записан в эквивалентном виде (хотя такая запись и не может непосредственно присутствовать в файле, описывающем типы ASN.1):

Type1 ::= [CONTEXT 0] EXPLICIT BOOLEAN

Кстати, формально полный эквивалент стандартного типа, например, BOOLEAN, может быть записан как:

BOOLEAN_Eq ::= [UNIVERSAL 1] IMPLICIT BOOLEAN

Еще одна интересная ситуация возникает в случае применения нотации IMPLICIT к изначально конструктивным типам, например к типу SEQUENCE. В этом случае новый тип будет также иметь конструктивную форму, а блок значения для нового типа всё так же будет браться из блока значения кодируемого типа SEQUENCE. Таким образом, для нотации IMPLICIT можно обозначить следующие правила:

    Блок значения для нового типа всегда берётся из блока значения кодируемого типа.
    Использование конструктивного или примитивного кодирования зависит от кодируемого типа – тип кодирования нового типа эквивалентен типу кодирования, применяемому в кодируемом типе.

Например, в приведенной ниже нотации тип PrimType, несмотря на применение IMPLICIT, будет иметь конструктивный тип:

ConstType ::= [0] REAL

PrimType ::= [PRIVATE 2] IMPLICIT ConstType

В заключение скажу, что для типа CHOICE по правилам кодирования ASN.1 должна всегда применяться нотация EXPLICIT (конструктивное кодирование).
9. Кодирование типа SEQUENCE

Тип SEQUENCE служит для логической группировки (объединения) закодированных значений для различных типов. Фактически само название SEQUENCE (в переводе "последовательность") указывает на область применения этого типа. Порядок следования типов в последовательности заранее определен и не может быть изменен.

Кодирование для этого типа является "конструктивным", то есть в блоке с закодированным значением содержатся дополнительные подблоки, кодирующие отдельные значения. За более подробным описанием отсылаю читателя к 1 разделу этой статьи.

Пример кодирования типа SEQUENCE. Предположим, что в последовательности должны быть закодированы два числа: одно целое (INTEGER), равное -128, и одно число с плавающей точкой (REAL), равное 0.15625 (представленное в разложении по основанию 2). Из соответствующих предыдущих разделов можно узнать, что целое число кодируется как последовательность октетов (02 01 80), а число с плавающей запятой кодируется как последовательность октетов (09 03 80 FB 05). Тогда тип SEQUENCE, содержащий эти два закодированных числа, будет кодироваться в виде:

30 08 02 01 80 09 03 80 FB 05

Здесь первый октет является идентификационным октетом и информирует о том, что закодировано значение типа SEQUENCE, и что используется конструктивный метод кодирования. Второй октет хранит количество октетов, в которых закодировано значение типа SEQUENCE. Следующие три октета представляют закодированное значение целого числа (-128), а последние 5 октетов – значение закодированного числа с плавающей точкой (0.15625).
10. Кодирование типа SET

Кодирование типа SET фактически полностью соответствует кодированию для типа SEQUENCE, за тем исключением, что порядок следования типов, закодированных с помощью SET, может изменяться. То есть если для примера взять числа из раздела о типе SEQUENCE, то фактически мы получаем два возможных (абсолютно равноценных) варианта кодирования их для типа SET:

Вариант 1: 31 08 02 01 80 09 03 80 FB 05

Вариант 2: 31 08 09 03 80 FB 05 02 01 80

Второй вариант просто помещает закодированное целое число после закодированного числа с плавающей точкой.

В типе SET также могут быть закодированы два (и более) значений, имеющих одинаковые типы. При декодировании их значения различаются с помощью применения "префиксных типов". О них уже было рассказано в разделе 8.
11. Кодирование типа BOOLEAN

Тип BOOLEAN может кодировать только два значение - TRUE (истина) или FALSE (ложь). Если кодируется значение FALSE, то в блоке значения должен быть только один октет, равный 00. Если кодируется значение TRUE, то в блоке значения должен быть только один октет, значение которого отлично от нуля. То есть следующие два варианта кодирования TRUE для типа BOOLEAN эквивалентны:

Вариант 1: 01 01 01

Вариант 2: 01 01 FF
Глава 12. Кодирование типа NULL

Значение типа NULL всегда постоянно и всегда кодируется всего двумя октетами 05 00, где первый октет является информационным октетом, а второй октет – октет длины, который всегда кодирует нулевую длину.
************************************************************************************
Как получить хэш открытого ключа для закрепления SSL?

Поскольку это веб-сайт, посвященный программированию , я хотел объяснить, как рассчитать хэш открытого ключа для закрепления открытого ключа. Это важно, потому что алгоритм полностью недокументирован. (Это даже не задокументировано каноническим расширением закрепления открытого ключа RFC 7469 для HTTP !

tl;dr: Base64(SHA256(SubjectPublicKeyInfo))

Сертификат не является (просто) открытым ключом

Первое, что нужно понять, это то, что открытый ключ - это просто число (например, 2048 битное число для RSA). Сертификат - это набор множества дополнительной информации (имена субъектов, хэши, цифровые подписи).

Это означает, что:

1. открытый ключ - это число

2. сертификат связывает веб-сайт с этим номером (например, stackoverflow.com)

ывод открытого ключа содержит хэш открытого ключа . Это не хэш сертификата. Это позволяет обновлять сертификаты, сохраняя при этом ваш открытый ключ.

Структура сертификата
Нам нужно извлечь открытый ключ из сертификата, поэтому нам нужно знать его структуру. Структура сертификата задокументирована (ужасно) в RFC 5280 - Профиль сертификата инфраструктуры и списка отзыва сертификатов (CRL) инфраструктуры открытого ключа Internet X.509.

С точки зрения программирования, Сертификат это:

struct Certificate {
   TBSCertificate      tbsCertificate,
   AlgorithmIdentifier signatureAlgorithm,
   BITSTRING           signatureValue
}

И это SubjectPublicKeyInfo внутри tbsCertificate который содержит то, что мы ищем:

struct TBSCertificate {
    EXPLICIT                version,
    CertificateSerialNumber serialNumber,
    AlgorithmIdentifier     signature,
    Name                    issuer,
    Validity                validity,
    Name                    subject,
    SubjectPublicKeyInfo    subjectPublicKeyInfo,
    //...optional extra stuff...
    }

Нам нужно взять SHA256 от необработанного subjectPublicKeyInfo.

digest = SHA256(certificate.tbsCertificate.subjectPublicKeyInfo);    
Это значение в кодировке base64 становится значением, которое мы помещаем в заголовки ответа нашего веб-сервера:

String pin = String.Format("max-age=%d; pin-sha256=\"%s\"", 
    31536000, //1 год
    System.Convert.ToBase64(digest));
response.Headers.Add("Public-Key-Pins",  pin);

Например:

Public-Key-Pins: max-age=31536000; pin-sha256="hUIG87ch71EZQYhZBEkq2VKBLjhussUw7nR8wyuY7rY=";

Что же такое на самом деле этот хеш?

В качестве примера вычислим PKP SHA256 хеш я собираюсь использовать текущий сертификат Facebook.com . Вы можете перейти на Facebook, просмотреть сертификат и сохранить его в DER PEM в кодировке base64:

Facebook.cer (PEM DER ASN.1 кодировке)

-----BEGIN CERTIFICATE-----
MIIH5DCCBsygAwIBAgIQDACZt9eJyfZmJjF+vOp8HDANBgkqhkiG9w0BAQsFADBw
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
d3cuZGlnaWNlcnQuY29tMS8wLQYDVQQDEyZEaWdpQ2VydCBTSEEyIEhpZ2ggQXNz
dXJhbmNlIFNlcnZlciBDQTAeFw0xNjEyMDkwMDAwMDBaFw0xODAxMjUxMjAwMDBa
MGkxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRMwEQYDVQQHEwpN
ZW5sbyBQYXJrMRcwFQYDVQQKEw5GYWNlYm9vaywgSW5jLjEXMBUGA1UEAwwOKi5m
YWNlYm9vay5jb20wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASg8YyvpzmIaFsT
Vg4VFbSnRe8bx+WFPCsE1GWKMTEi6qOS7WSdumWB47YSdtizC0Xx/wooFJxP3HOp
s0ktoHbTo4IFSjCCBUYwHwYDVR0jBBgwFoAUUWj/kK8CB3U8zNllZGKiErhZcjsw
HQYDVR0OBBYEFMuYKIyhcufiMqmaPfINoYFWoRqLMIHHBgNVHREEgb8wgbyCDiou
ZmFjZWJvb2suY29tgg4qLmZhY2Vib29rLm5ldIIIKi5mYi5jb22CCyouZmJjZG4u
bmV0ggsqLmZic2J4LmNvbYIQKi5tLmZhY2Vib29rLmNvbYIPKi5tZXNzZW5nZXIu
Y29tgg4qLnh4LmZiY2RuLm5ldIIOKi54eS5mYmNkbi5uZXSCDioueHouZmJjZG4u
bmV0ggxmYWNlYm9vay5jb22CBmZiLmNvbYINbWVzc2VuZ2VyLmNvbTAOBgNVHQ8B
Af8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHUGA1UdHwRu
MGwwNKAyoDCGLmh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9zaGEyLWhhLXNlcnZl
ci1nNS5jcmwwNKAyoDCGLmh0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9zaGEyLWhh
LXNlcnZlci1nNS5jcmwwTAYDVR0gBEUwQzA3BglghkgBhv1sAQEwKjAoBggrBgEF
BQcCARYcaHR0cHM6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzAIBgZngQwBAgIwgYMG
CCsGAQUFBwEBBHcwdTAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQu
Y29tME0GCCsGAQUFBzAChkFodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGln
aUNlcnRTSEEySGlnaEFzc3VyYW5jZVNlcnZlckNBLmNydDAMBgNVHRMBAf8EAjAA
MIICsAYKKwYBBAHWeQIEAgSCAqAEggKcApoAdgCkuQmQtBhYFIe7E6LMZ3AKPDWY
BPkb37jjd80OyA3cEAAAAVjl02IEAAAEAwBHMEUCIQDvWFsUeqWE/xwIYcXPvbb5
ExzfHBZTNwfnUf4RPO/lBgIgdOGmr0j7+u8/S+7tfFw71ZEjqpwJELl/sEFuQdPn
pwQBLwCsO5rtf6lnR1cVnm19V1Zy+dmBAJQem97/7KExO3V4LQAAAVjl02IoAAAE
AQEAYvnMV+BfP3Wrk4yFQE/Zx5WsjSabYOpLj1Tj5xFaoVoHdGqLCf/Hi+Vv0IRy
ePKFBCSW0+3eA589+WnCDMwcJlBYeZV8MlvHFZg3a66Uhx/OAvoetb0mCtUpnmIE
UwLX/eMNEvjg2qTH3/33ysCo2l25+/EcR8upF+2KIcmnk5WwaJzfq7cFPQc4Cvcz
mTHasJi/jmVaIaJ9HC50g3dx584TQX26lDLddF/Li4uEbJ7TSopnTzjQdWBtWbMF
h3bcfhFCKaqK2kIJV3bgup5HibEnZ2LPm6lekY072ZFCGM4QYc4ukqzou2JWCRmG
o0dMHJhnvQXpnIQGwATqCD4Q1AB2AFYUBpov18Ls0/XhvUSyPsdGdrm8mRFcwO+U
mFXWidDdAAABWOXTYrkAAAQDAEcwRQIgGhXXbwUO5bD4Ts/Q0gqZwUS2vl/A4Hem
k7ovxl82v9oCIQCbtkflDXbcunY4MAQCbKlnesPGc/nftA84xDhJpxFHWQB3AO5L
vbd1zmC64UJpH6vhnmajD35fsHLYgwDEe4l6qP3LAAABWOXTZBEAAAQDAEgwRgIh
AKubngQoa5Iak8eCOrffH7Xx3AP1NMb5pFw35nt2VSeRAiEA47Kq1UQcDXIEsV+W
nuPd9LM5kpdeu0+TiHKtTLRQr0swDQYJKoZIhvcNAQELBQADggEBADrNSsoonbj1
YGjwy9t9wP9+kZBwrNMO2n5N5fQNhGawkEAX+lXlzgm3TqYlTNi6sCFbPBAErim3
aMVlWuOlctgnjtAdmdWZ4qEONrBLHPGgukDJ3Uen/EC/gwK6KdBCb4Ttp6MMPY1c
hb/ciTLi3QUUU4h4OJWqUjvccBCDs/LydNjKWZZTxLJmxRSmfpyCU3uU2XHHMNlo
8UTIlqZsOtdqhg7/Q/cvMDHDkcI/tqelmg0MD2H9KpcmAvVkwgjn+BVpv5HELl+0
EP0UhYknI1B6LBecJuj7jI26eXZdX35CYkpI/SZA9KK+OYKHh6vCxKqnRZ9ZQUOj
XnIWKQeV5Hg=
-----END CERTIFICATE-----

Все вышеперечисленное закодировано в base64. Давайте расшифруем его в hex:

Facebook.cer (DER ASN.1 encoded)

30 82 07 e4 30 82 06 cc a0 03  02 01 02 02 10 0c 00 99 b7 d7  89 c9 f6 66 26 31 7e bc ea 7c  1c 30 0d 06 09 2a 86 48 86 f7 
0d 01 01 0b 05 00 30 70 31 0b  30 09 06 03 55 04 06 13 02 55  53 31 15 30 13 06 03 55 04 0a  13 0c 44 69 67 69 43 65 72 74 
20 49 6e 63 31 19 30 17 06 03  55 04 0b 13 10 77 77 77 2e 64  69 67 69 63 65 72 74 2e 63 6f  6d 31 2f 30 2d 06 03 55 04 03 
13 26 44 69 67 69 43 65 72 74  20 53 48 41 32 20 48 69 67 68  20 41 73 73 75 72 61 6e 63 65  20 53 65 72 76 65 72 20 43 41 
30 1e 17 0d 31 36 31 32 30 39  30 30 30 30 30 30 5a 17 0d 31  38 30 31 32 35 31 32 30 30 30  30 5a 30 69 31 0b 30 09 06 03 
55 04 06 13 02 55 53 31 13 30  11 06 03 55 04 08 13 0a 43 61  6c 69 66 6f 72 6e 69 61 31 13  30 11 06 03 55 04 07 13 0a 4d 
65 6e 6c 6f 20 50 61 72 6b 31  17 30 15 06 03 55 04 0a 13 0e  46 61 63 65 62 6f 6f 6b 2c 20  49 6e 63 2e 31 17 30 15 06 03 
55 04 03 0c 0e 2a 2e 66 61 63  65 62 6f 6f 6b 2e 63 6f 6d 30  59 30 13 06 07 2a 86 48 ce 3d  02 01 06 08 2a 86 48 ce 3d 03 
01 07 03 42 00 04 a0 f1 8c af  a7 39 88 68 5b 13 56 0e 15 15  b4 a7 45 ef 1b c7 e5 85 3c 2b  04 d4 65 8a 31 31 22 ea a3 92 
ed 64 9d ba 65 81 e3 b6 12 76  d8 b3 0b 45 f1 ff 0a 28 14 9c  4f dc 73 a9 b3 49 2d a0 76 d3  a3 82 05 4a 30 82 05 46 30 1f 
06 03 55 1d 23 04 18 30 16 80  14 51 68 ff 90 af 02 07 75 3c  cc d9 65 64 62 a2 12 b8 59 72  3b 30 1d 06 03 55 1d 0e 04 16 
04 14 cb 98 28 8c a1 72 e7 e2  32 a9 9a 3d f2 0d a1 81 56 a1  1a 8b 30 81 c7 06 03 55 1d 11  04 81 bf 30 81 bc 82 0e 2a 2e 
66 61 63 65 62 6f 6f 6b 2e 63  6f 6d 82 0e 2a 2e 66 61 63 65  62 6f 6f 6b 2e 6e 65 74 82 08  2a 2e 66 62 2e 63 6f 6d 82 0b 
2a 2e 66 62 63 64 6e 2e 6e 65  74 82 0b 2a 2e 66 62 73 62 78  2e 63 6f 6d 82 10 2a 2e 6d 2e  66 61 63 65 62 6f 6f 6b 2e 63 
6f 6d 82 0f 2a 2e 6d 65 73 73  65 6e 67 65 72 2e 63 6f 6d 82  0e 2a 2e 78 78 2e 66 62 63 64  6e 2e 6e 65 74 82 0e 2a 2e 78 
79 2e 66 62 63 64 6e 2e 6e 65  74 82 0e 2a 2e 78 7a 2e 66 62  63 64 6e 2e 6e 65 74 82 0c 66  61 63 65 62 6f 6f 6b 2e 63 6f 
6d 82 06 66 62 2e 63 6f 6d 82  0d 6d 65 73 73 65 6e 67 65 72  2e 63 6f 6d 30 0e 06 03 55 1d  0f 01 01 ff 04 04 03 02 07 80 
30 1d 06 03 55 1d 25 04 16 30  14 06 08 2b 06 01 05 05 07 03  01 06 08 2b 06 01 05 05 07 03  02 30 75 06 03 55 1d 1f 04 6e 
30 6c 30 34 a0 32 a0 30 86 2e  68 74 74 70 3a 2f 2f 63 72 6c  33 2e 64 69 67 69 63 65 72 74  2e 63 6f 6d 2f 73 68 61 32 2d 
68 61 2d 73 65 72 76 65 72 2d  67 35 2e 63 72 6c 30 34 a0 32  a0 30 86 2e 68 74 74 70 3a 2f  2f 63 72 6c 34 2e 64 69 67 69 
63 65 72 74 2e 63 6f 6d 2f 73  68 61 32 2d 68 61 2d 73 65 72  76 65 72 2d 67 35 2e 63 72 6c  30 4c 06 03 55 1d 20 04 45 30 
43 30 37 06 09 60 86 48 01 86  fd 6c 01 01 30 2a 30 28 06 08  2b 06 01 05 05 07 02 01 16 1c  68 74 74 70 73 3a 2f 2f 77 77 
77 2e 64 69 67 69 63 65 72 74  2e 63 6f 6d 2f 43 50 53 30 08  06 06 67 81 0c 01 02 02 30 81  83 06 08 2b 06 01 05 05 07 01 
01 04 77 30 75 30 24 06 08 2b  06 01 05 05 07 30 01 86 18 68  74 74 70 3a 2f 2f 6f 63 73 70  2e 64 69 67 69 63 65 72 74 2e 
63 6f 6d 30 4d 06 08 2b 06 01  05 05 07 30 02 86 41 68 74 74  70 3a 2f 2f 63 61 63 65 72 74  73 2e 64 69 67 69 63 65 72 74 
2e 63 6f 6d 2f 44 69 67 69 43  65 72 74 53 48 41 32 48 69 67  68 41 73 73 75 72 61 6e 63 65  53 65 72 76 65 72 43 41 2e 63 
72 74 30 0c 06 03 55 1d 13 01  01 ff 04 02 30 00 30 82 02 b0  06 0a 2b 06 01 04 01 d6 79 02  04 02 04 82 02 a0 04 82 02 9c 
02 9a 00 76 00 a4 b9 09 90 b4  18 58 14 87 bb 13 a2 cc 67 70  0a 3c 35 98 04 f9 1b df b8 e3  77 cd 0e c8 0d dc 10 00 00 01 
58 e5 d3 62 04 00 00 04 03 00  47 30 45 02 21 00 ef 58 5b 14  7a a5 84 ff 1c 08 61 c5 cf bd  b6 f9 13 1c df 1c 16 53 37 07 
e7 51 fe 11 3c ef e5 06 02 20  74 e1 a6 af 48 fb fa ef 3f 4b  ee ed 7c 5c 3b d5 91 23 aa 9c  09 10 b9 7f b0 41 6e 41 d3 e7 
a7 04 01 2f 00 ac 3b 9a ed 7f  a9 67 47 57 15 9e 6d 7d 57 56  72 f9 d9 81 00 94 1e 9b de ff  ec a1 31 3b 75 78 2d 00 00 01 
58 e5 d3 62 28 00 00 04 01 01  00 62 f9 cc 57 e0 5f 3f 75 ab  93 8c 85 40 4f d9 c7 95 ac 8d  26 9b 60 ea 4b 8f 54 e3 e7 11 
5a a1 5a 07 74 6a 8b 09 ff c7  8b e5 6f d0 84 72 78 f2 85 04  24 96 d3 ed de 03 9f 3d f9 69  c2 0c cc 1c 26 50 58 79 95 7c 
32 5b c7 15 98 37 6b ae 94 87  1f ce 02 fa 1e b5 bd 26 0a d5  29 9e 62 04 53 02 d7 fd e3 0d  12 f8 e0 da a4 c7 df fd f7 ca 
c0 a8 da 5d b9 fb f1 1c 47 cb  a9 17 ed 8a 21 c9 a7 93 95 b0  68 9c df ab b7 05 3d 07 38 0a  f7 33 99 31 da b0 98 bf 8e 65 
5a 21 a2 7d 1c 2e 74 83 77 71  e7 ce 13 41 7d ba 94 32 dd 74  5f cb 8b 8b 84 6c 9e d3 4a 8a  67 4f 38 d0 75 60 6d 59 b3 05 
87 76 dc 7e 11 42 29 aa 8a da  42 09 57 76 e0 ba 9e 47 89 b1  27 67 62 cf 9b a9 5e 91 8d 3b  d9 91 42 18 ce 10 61 ce 2e 92 
ac e8 bb 62 56 09 19 86 a3 47  4c 1c 98 67 bd 05 e9 9c 84 06  c0 04 ea 08 3e 10 d4 00 76 00  56 14 06 9a 2f d7 c2 ec d3 f5 
e1 bd 44 b2 3e c7 46 76 b9 bc  99 11 5c c0 ef 94 98 55 d6 89  d0 dd 00 00 01 58 e5 d3 62 b9  00 00 04 03 00 47 30 45 02 20 
1a 15 d7 6f 05 0e e5 b0 f8 4e  cf d0 d2 0a 99 c1 44 b6 be 5f  c0 e0 77 a6 93 ba 2f c6 5f 36  bf da 02 21 00 9b b6 47 e5 0d 
76 dc ba 76 38 30 04 02 6c a9  67 7a c3 c6 73 f9 df b4 0f 38  c4 38 49 a7 11 47 59 00 77 00  ee 4b bd b7 75 ce 60 ba e1 42 
69 1f ab e1 9e 66 a3 0f 7e 5f  b0 72 d8 83 00 c4 7b 89 7a a8  fd cb 00 00 01 58 e5 d3 64 11  00 00 04 03 00 48 30 46 02 21 
00 ab 9b 9e 04 28 6b 92 1a 93  c7 82 3a b7 df 1f b5 f1 dc 03  f5 34 c6 f9 a4 5c 37 e6 7b 76  55 27 91 02 21 00 e3 b2 aa d5 
44 1c 0d 72 04 b1 5f 96 9e e3  dd f4 b3 39 92 97 5e bb 4f 93  88 72 ad 4c b4 50 af 4b 30 0d  06 09 2a 86 48 86 f7 0d 01 01 
0b 05 00 03 82 01 01 00 3a cd  4a ca 28 9d b8 f5 60 68 f0 cb  db 7d c0 ff 7e 91 90 70 ac d3  0e da 7e 4d e5 f4 0d 84 66 b0 
90 40 17 fa 55 e5 ce 09 b7 4e  a6 25 4c d8 ba b0 21 5b 3c 10  04 ae 29 b7 68 c5 65 5a e3 a5  72 d8 27 8e d0 1d 99 d5 99 e2 
a1 0e 36 b0 4b 1c f1 a0 ba 40  c9 dd 47 a7 fc 40 bf 83 02 ba  29 d0 42 6f 84 ed a7 a3 0c 3d  8d 5c 85 bf dc 89 32 e2 dd 05 
14 53 88 78 38 95 aa 52 3b dc  70 10 83 b3 f2 f2 74 d8 ca 59  96 53 c4 b2 66 c5 14 a6 7e 9c  82 53 7b 94 d9 71 c7 30 d9 68 
f1 44 c8 96 a6 6c 3a d7 6a 86  0e ff 43 f7 2f 30 31 c3 91 c2  3f b6 a7 a5 9a 0d 0c 0f 61 fd  2a 97 26 02 f5 64 c2 08 e7 f8 
15 69 bf 91 c4 2e 5f b4 10 fd  14 85 89 27 23 50 7a 2c 17 9c  26 e8 fb 8c 8d ba 79 76 5d 5f  7e 42 62 4a 48 fd 26 40 f4 a2 
be 39 82 87 87 ab c2 c4 aa a7  45 9f 59 41 43 a3 5e 72 16 29  07 95 e4 78


Поскольку это веб-сайт, посвященный программированию , я хотел объяснить, как рассчитать хэш открытого ключа для закрепления открытого ключа. Это важно, потому что алгоритм полностью недокументирован. (Это даже не задокументировано каноническим расширением закрепления открытого ключа RFC 7469 для HTTP !

tl; dr : Base64(SHA256(SubjectPublicKeyInfo))

Сертификат не является (просто) открытым ключом
Первое, что нужно понять, это то, что открытый ключ - это просто число (например, 2048 битное число для RSA). Сертификат - это набор множества дополнительной информации (имена субъектов, хэши, цифровые подписи).

Это означает, что:

открытый ключ - это число
сертификат связывает веб-сайт с этим номером (например, stackoverflow.com)
Вывод открытого ключа содержит хэш открытого ключа . Это не хэш сертификата. Это позволяет обновлять сертификаты, сохраняя при этом ваш открытый ключ.

Структура сертификата
Нам нужно извлечь открытый ключ из сертификата, поэтому нам нужно знать его структуру. Структура сертификата задокументирована (ужасно) в RFC 5280 - Профиль сертификата инфраструктуры и списка отзыва сертификатов (CRL) инфраструктуры открытого ключа Internet X.509.

С точки зрения программирования, Сертификат это:

 struct Certificate { TBSCertificate tbsCertificate, AlgorithmIdentifier signatureAlgorithm, BITSTRING signatureValue } 
И это SubjectPublicKeyInfo внутри tbsCertificate который содержит то, что мы ищем:

 struct TBSCertificate { EXPLICIT version, CertificateSerialNumber serialNumber, AlgorithmIdentifier signature, Name issuer, Validity validity, Name subject, SubjectPublicKeyInfo subjectPublicKeyInfo, //...optional extra stuff... } 
Нам нужно взять SHA256 необработанной темы PublicKeyInfo .

 digest = SHA256(certificate.tbsCertificate.subjectPublicKeyInfo); 
Это значение в кодировке base64 становится значением, которое мы помещаем в заголовки ответа нашего веб-сервера:

 String pin = String.Format("max-age=%d; pin-sha256=\"%s\"", 31536000, //1 year System.Convert.ToBase64(digest)); response.Headers.Add("Public-Key-Pins", pin); 
Например:

 Public-Key-Pins: max-age=31536000; pin-sha256="hUIG87ch71EZQYhZBEkq2VKBLjhussUw7nR8wyuY7rY="; 
Но что я на самом деле хэш?
В качестве примера вычисления хеша PKP SHA256 я собираюсь использовать текущий сертификат Facebook.com . Вы можете перейти на Facebook, просмотреть сертификат и сохранить его в DER PEM в кодировке base64:

Facebook.cer (кодируется PEM DER ASN.1)

 -----BEGIN CERTIFICATE----- MIIH5DCCBsygAwIBAgIQDACZt9eJyfZmJjF+vOp8HDANBgkqhkiG9w0BAQsFADBw MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 d3cuZGlnaWNlcnQuY29tMS8wLQYDVQQDEyZEaWdpQ2VydCBTSEEyIEhpZ2ggQXNz dXJhbmNlIFNlcnZlciBDQTAeFw0xNjEyMDkwMDAwMDBaFw0xODAxMjUxMjAwMDBa MGkxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRMwEQYDVQQHEwpN ZW5sbyBQYXJrMRcwFQYDVQQKEw5GYWNlYm9vaywgSW5jLjEXMBUGA1UEAwwOKi5m YWNlYm9vay5jb20wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASg8YyvpzmIaFsT Vg4VFbSnRe8bx+WFPCsE1GWKMTEi6qOS7WSdumWB47YSdtizC0Xx/wooFJxP3HOp s0ktoHbTo4IFSjCCBUYwHwYDVR0jBBgwFoAUUWj/kK8CB3U8zNllZGKiErhZcjsw HQYDVR0OBBYEFMuYKIyhcufiMqmaPfINoYFWoRqLMIHHBgNVHREEgb8wgbyCDiou ZmFjZWJvb2suY29tgg4qLmZhY2Vib29rLm5ldIIIKi5mYi5jb22CCyouZmJjZG4u bmV0ggsqLmZic2J4LmNvbYIQKi5tLmZhY2Vib29rLmNvbYIPKi5tZXNzZW5nZXIu Y29tgg4qLnh4LmZiY2RuLm5ldIIOKi54eS5mYmNkbi5uZXSCDioueHouZmJjZG4u bmV0ggxmYWNlYm9vay5jb22CBmZiLmNvbYINbWVzc2VuZ2VyLmNvbTAOBgNVHQ8B Af8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHUGA1UdHwRu MGwwNKAyoDCGLmh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9zaGEyLWhhLXNlcnZl ci1nNS5jcmwwNKAyoDCGLmh0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9zaGEyLWhh LXNlcnZlci1nNS5jcmwwTAYDVR0gBEUwQzA3BglghkgBhv1sAQEwKjAoBggrBgEF BQcCARYcaHR0cHM6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzAIBgZngQwBAgIwgYMG CCsGAQUFBwEBBHcwdTAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQu Y29tME0GCCsGAQUFBzAChkFodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGln aUNlcnRTSEEySGlnaEFzc3VyYW5jZVNlcnZlckNBLmNydDAMBgNVHRMBAf8EAjAA MIICsAYKKwYBBAHWeQIEAgSCAqAEggKcApoAdgCkuQmQtBhYFIe7E6LMZ3AKPDWY BPkb37jjd80OyA3cEAAAAVjl02IEAAAEAwBHMEUCIQDvWFsUeqWE/xwIYcXPvbb5 ExzfHBZTNwfnUf4RPO/lBgIgdOGmr0j7+u8/S+7tfFw71ZEjqpwJELl/sEFuQdPn pwQBLwCsO5rtf6lnR1cVnm19V1Zy+dmBAJQem97/7KExO3V4LQAAAVjl02IoAAAE AQEAYvnMV+BfP3Wrk4yFQE/Zx5WsjSabYOpLj1Tj5xFaoVoHdGqLCf/Hi+Vv0IRy ePKFBCSW0+3eA589+WnCDMwcJlBYeZV8MlvHFZg3a66Uhx/OAvoetb0mCtUpnmIE UwLX/eMNEvjg2qTH3/33ysCo2l25+/EcR8upF+2KIcmnk5WwaJzfq7cFPQc4Cvcz mTHasJi/jmVaIaJ9HC50g3dx584TQX26lDLddF/Li4uEbJ7TSopnTzjQdWBtWbMF h3bcfhFCKaqK2kIJV3bgup5HibEnZ2LPm6lekY072ZFCGM4QYc4ukqzou2JWCRmG o0dMHJhnvQXpnIQGwATqCD4Q1AB2AFYUBpov18Ls0/XhvUSyPsdGdrm8mRFcwO+U mFXWidDdAAABWOXTYrkAAAQDAEcwRQIgGhXXbwUO5bD4Ts/Q0gqZwUS2vl/A4Hem k7ovxl82v9oCIQCbtkflDXbcunY4MAQCbKlnesPGc/nftA84xDhJpxFHWQB3AO5L vbd1zmC64UJpH6vhnmajD35fsHLYgwDEe4l6qP3LAAABWOXTZBEAAAQDAEgwRgIh AKubngQoa5Iak8eCOrffH7Xx3AP1NMb5pFw35nt2VSeRAiEA47Kq1UQcDXIEsV+W nuPd9LM5kpdeu0+TiHKtTLRQr0swDQYJKoZIhvcNAQELBQADggEBADrNSsoonbj1 YGjwy9t9wP9+kZBwrNMO2n5N5fQNhGawkEAX+lXlzgm3TqYlTNi6sCFbPBAErim3 aMVlWuOlctgnjtAdmdWZ4qEONrBLHPGgukDJ3Uen/EC/gwK6KdBCb4Ttp6MMPY1c hb/ciTLi3QUUU4h4OJWqUjvccBCDs/LydNjKWZZTxLJmxRSmfpyCU3uU2XHHMNlo 8UTIlqZsOtdqhg7/Q/cvMDHDkcI/tqelmg0MD2H9KpcmAvVkwgjn+BVpv5HELl+0 EP0UhYknI1B6LBecJuj7jI26eXZdX35CYkpI/SZA9KK+OYKHh6vCxKqnRZ9ZQUOj XnIWKQeV5Hg= -----END CERTIFICATE----- 
Все вышеперечисленное закодировано в base64. Давайте расшифруем его в гекс:

Facebook.cer (кодируется DER ASN.1)

 30 82 07 e4 30 82 06 cc a0 03 02 01 02 02 10 0c 00 99 b7 d7 89 c9 f6 66 26 31 7e bc ea 7c 1c 30 0d 06 09 2a 86 48 86 f7 0d 01 01 0b 05 00 30 70 31 0b 30 09 06 03 55 04 06 13 02 55 53 31 15 30 13 06 03 55 04 0a 13 0c 44 69 67 69 43 65 72 74 20 49 6e 63 31 19 30 17 06 03 55 04 0b 13 10 77 77 77 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 31 2f 30 2d 06 03 55 04 03 13 26 44 69 67 69 43 65 72 74 20 53 48 41 32 20 48 69 67 68 20 41 73 73 75 72 61 6e 63 65 20 53 65 72 76 65 72 20 43 41 30 1e 17 0d 31 36 31 32 30 39 30 30 30 30 30 30 5a 17 0d 31 38 30 31 32 35 31 32 30 30 30 30 5a 30 69 31 0b 30 09 06 03 55 04 06 13 02 55 53 31 13 30 11 06 03 55 04 08 13 0a 43 61 6c 69 66 6f 72 6e 69 61 31 13 30 11 06 03 55 04 07 13 0a 4d 65 6e 6c 6f 20 50 61 72 6b 31 17 30 15 06 03 55 04 0a 13 0e 46 61 63 65 62 6f 6f 6b 2c 20 49 6e 63 2e 31 17 30 15 06 03 55 04 03 0c 0e 2a 2e 66 61 63 65 62 6f 6f 6b 2e 63 6f 6d 30 59 30 13 06 07 2a 86 48 ce 3d 02 01 06 08 2a 86 48 ce 3d 03 01 07 03 42 00 04 a0 f1 8c af a7 39 88 68 5b 13 56 0e 15 15 b4 a7 45 ef 1b c7 e5 85 3c 2b 04 d4 65 8a 31 31 22 ea a3 92 ed 64 9d ba 65 81 e3 b6 12 76 d8 b3 0b 45 f1 ff 0a 28 14 9c 4f dc 73 a9 b3 49 2d a0 76 d3 a3 82 05 4a 30 82 05 46 30 1f 06 03 55 1d 23 04 18 30 16 80 14 51 68 ff 90 af 02 07 75 3c cc d9 65 64 62 a2 12 b8 59 72 3b 30 1d 06 03 55 1d 0e 04 16 04 14 cb 98 28 8c a1 72 e7 e2 32 a9 9a 3d f2 0d a1 81 56 a1 1a 8b 30 81 c7 06 03 55 1d 11 04 81 bf 30 81 bc 82 0e 2a 2e 66 61 63 65 62 6f 6f 6b 2e 63 6f 6d 82 0e 2a 2e 66 61 63 65 62 6f 6f 6b 2e 6e 65 74 82 08 2a 2e 66 62 2e 63 6f 6d 82 0b 2a 2e 66 62 63 64 6e 2e 6e 65 74 82 0b 2a 2e 66 62 73 62 78 2e 63 6f 6d 82 10 2a 2e 6d 2e 66 61 63 65 62 6f 6f 6b 2e 63 6f 6d 82 0f 2a 2e 6d 65 73 73 65 6e 67 65 72 2e 63 6f 6d 82 0e 2a 2e 78 78 2e 66 62 63 64 6e 2e 6e 65 74 82 0e 2a 2e 78 79 2e 66 62 63 64 6e 2e 6e 65 74 82 0e 2a 2e 78 7a 2e 66 62 63 64 6e 2e 6e 65 74 82 0c 66 61 63 65 62 6f 6f 6b 2e 63 6f 6d 82 06 66 62 2e 63 6f 6d 82 0d 6d 65 73 73 65 6e 67 65 72 2e 63 6f 6d 30 0e 06 03 55 1d 0f 01 01 ff 04 04 03 02 07 80 30 1d 06 03 55 1d 25 04 16 30 14 06 08 2b 06 01 05 05 07 03 01 06 08 2b 06 01 05 05 07 03 02 30 75 06 03 55 1d 1f 04 6e 30 6c 30 34 a0 32 a0 30 86 2e 68 74 74 70 3a 2f 2f 63 72 6c 33 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 2f 73 68 61 32 2d 68 61 2d 73 65 72 76 65 72 2d 67 35 2e 63 72 6c 30 34 a0 32 a0 30 86 2e 68 74 74 70 3a 2f 2f 63 72 6c 34 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 2f 73 68 61 32 2d 68 61 2d 73 65 72 76 65 72 2d 67 35 2e 63 72 6c 30 4c 06 03 55 1d 20 04 45 30 43 30 37 06 09 60 86 48 01 86 fd 6c 01 01 30 2a 30 28 06 08 2b 06 01 05 05 07 02 01 16 1c 68 74 74 70 73 3a 2f 2f 77 77 77 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 2f 43 50 53 30 08 06 06 67 81 0c 01 02 02 30 81 83 06 08 2b 06 01 05 05 07 01 01 04 77 30 75 30 24 06 08 2b 06 01 05 05 07 30 01 86 18 68 74 74 70 3a 2f 2f 6f 63 73 70 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 30 4d 06 08 2b 06 01 05 05 07 30 02 86 41 68 74 74 70 3a 2f 2f 63 61 63 65 72 74 73 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 2f 44 69 67 69 43 65 72 74 53 48 41 32 48 69 67 68 41 73 73 75 72 61 6e 63 65 53 65 72 76 65 72 43 41 2e 63 72 74 30 0c 06 03 55 1d 13 01 01 ff 04 02 30 00 30 82 02 b0 06 0a 2b 06 01 04 01 d6 79 02 04 02 04 82 02 a0 04 82 02 9c 02 9a 00 76 00 a4 b9 09 90 b4 18 58 14 87 bb 13 a2 cc 67 70 0a 3c 35 98 04 f9 1b df b8 e3 77 cd 0e c8 0d dc 10 00 00 01 58 e5 d3 62 04 00 00 04 03 00 47 30 45 02 21 00 ef 58 5b 14 7a a5 84 ff 1c 08 61 c5 cf bd b6 f9 13 1c df 1c 16 53 37 07 e7 51 fe 11 3c ef e5 06 02 20 74 e1 a6 af 48 fb fa ef 3f 4b ee ed 7c 5c 3b d5 91 23 aa 9c 09 10 b9 7f b0 41 6e 41 d3 e7 a7 04 01 2f 00 ac 3b 9a ed 7f a9 67 47 57 15 9e 6d 7d 57 56 72 f9 d9 81 00 94 1e 9b de ff ec a1 31 3b 75 78 2d 00 00 01 58 e5 d3 62 28 00 00 04 01 01 00 62 f9 cc 57 e0 5f 3f 75 ab 93 8c 85 40 4f d9 c7 95 ac 8d 26 9b 60 ea 4b 8f 54 e3 e7 11 5a a1 5a 07 74 6a 8b 09 ff c7 8b e5 6f d0 84 72 78 f2 85 04 24 96 d3 ed de 03 9f 3d f9 69 c2 0c cc 1c 26 50 58 79 95 7c 32 5b c7 15 98 37 6b ae 94 87 1f ce 02 fa 1e b5 bd 26 0a d5 29 9e 62 04 53 02 d7 fd e3 0d 12 f8 e0 da a4 c7 df fd f7 ca c0 a8 da 5d b9 fb f1 1c 47 cb a9 17 ed 8a 21 c9 a7 93 95 b0 68 9c df ab b7 05 3d 07 38 0a f7 33 99 31 da b0 98 bf 8e 65 5a 21 a2 7d 1c 2e 74 83 77 71 e7 ce 13 41 7d ba 94 32 dd 74 5f cb 8b 8b 84 6c 9e d3 4a 8a 67 4f 38 d0 75 60 6d 59 b3 05 87 76 dc 7e 11 42 29 aa 8a da 42 09 57 76 e0 ba 9e 47 89 b1 27 67 62 cf 9b a9 5e 91 8d 3b d9 91 42 18 ce 10 61 ce 2e 92 ac e8 bb 62 56 09 19 86 a3 47 4c 1c 98 67 bd 05 e9 9c 84 06 c0 04 ea 08 3e 10 d4 00 76 00 56 14 06 9a 2f d7 c2 ec d3 f5 e1 bd 44 b2 3e c7 46 76 b9 bc 99 11 5c c0 ef 94 98 55 d6 89 d0 dd 00 00 01 58 e5 d3 62 b9 00 00 04 03 00 47 30 45 02 20 1a 15 d7 6f 05 0e e5 b0 f8 4e cf d0 d2 0a 99 c1 44 b6 be 5f c0 e0 77 a6 93 ba 2f c6 5f 36 bf da 02 21 00 9b b6 47 e5 0d 76 dc ba 76 38 30 04 02 6c a9 67 7a c3 c6 73 f9 df b4 0f 38 c4 38 49 a7 11 47 59 00 77 00 ee 4b bd b7 75 ce 60 ba e1 42 69 1f ab e1 9e 66 a3 0f 7e 5f b0 72 d8 83 00 c4 7b 89 7a a8 fd cb 00 00 01 58 e5 d3 64 11 00 00 04 03 00 48 30 46 02 21 00 ab 9b 9e 04 28 6b 92 1a 93 c7 82 3a b7 df 1f b5 f1 dc 03 f5 34 c6 f9 a4 5c 37 e6 7b 76 55 27 91 02 21 00 e3 b2 aa d5 44 1c 0d 72 04 b1 5f 96 9e e3 dd f4 b3 39 92 97 5e bb 4f 93 88 72 ad 4c b4 50 af 4b 30 0d 06 09 2a 86 48 86 f7 0d 01 01 0b 05 00 03 82 01 01 00 3a cd 4a ca 28 9d b8 f5 60 68 f0 cb db 7d c0 ff 7e 91 90 70 ac d3 0e da 7e 4d e5 f4 0d 84 66 b0 90 40 17 fa 55 e5 ce 09 b7 4e a6 25 4c d8 ba b0 21 5b 3c 10 04 ae 29 b7 68 c5 65 5a e3 a5 72 d8 27 8e d0 1d 99 d5 99 e2 a1 0e 36 b0 4b 1c f1 a0 ba 40 c9 dd 47 a7 fc 40 bf 83 02 ba 29 d0 42 6f 84 ed a7 a3 0c 3d 8d 5c 85 bf dc 89 32 e2 dd 05 14 53 88 78 38 95 aa 52 3b dc 70 10 83 b3 f2 f2 74 d8 ca 59 96 53 c4 b2 66 c5 14 a6 7e 9c 82 53 7b 94 d9 71 c7 30 d9 68 f1 44 c8 96 a6 6c 3a d7 6a 86 0e ff 43 f7 2f 30 31 c3 91 c2 3f b6 a7 a5 9a 0d 0c 0f 61 fd 2a 97 26 02 f5 64 c2 08 e7 f8 15 69 bf 91 c4 2e 5f b4 10 fd 14 85 89 27 23 50 7a 2c 17 9c 26 e8 fb 8c 8d ba 79 76 5d 5f 7e 42 62 4a 48 fd 26 40 f4 a2 be 39 82 87 87 ab c2 c4 aa a7 45 9f 59 41 43 a3 5e 72 16 29 07 95 e4 78 
Вышеупомянутый двоичный код закодирован в DER-варианте ASN.1. Мы можем использовать превосходный javascript ASN.1 декодер, чтобы декодировать его для нас:

30 82 07 e4             ;30=SEQUENCE (0x07e4 bytes)
|- tbsCertificate
|  30 82 06 cc                          ;30=SEQUENCE (0x66cc bytes)
|  |- Version (0x03 bytes)
|  |    a0 03 02 01 02
|  |- SerialNumber (0x10 bytes)
|  |    02 10 0c 00 99 b7 d7 89 c9 f6 66 26 31 7e bc ea 7c 1c
|  |- Signature (0x0d bytes)
|  |    30 0d 06 09 2a 86 48 86 f7 0d 01 01 0b 05 00
|  |- Issuer (0x70 bytes)
|  |    30 70 31 0b 30 09 06 03 55 04 06 13 02 55 53 31 15 30 13 06 03 55 04 0a 13 0c 44 69 67 69 43 65 72 74 20 49 6e 63 31 19 30 17 06 03 55 04 0b 13 10 77 77 77 2e 64 69 67 69 63 65 72 74 2e 63 6f 6d 31 2f 30 2d 06 03 55 04 03 13 26 44 69 67 69 43 65 72 74 20 53 48 41 32 20 48 69 67 68 20 41 73 73 75 72 61 6e 63 65 20 53 65 72 76 65 72 20 43 41 
|  |- Validity (0x1e bytes)
|  |    30 1e 17 0d 31 36 31 32 30 39 30 30 30 30 30 30 5a 17 0d 31 38 30 31 32 35 31 32 30 30 30 30 5a 
|  |- Subject (0x69 bytes)
|  |    30 69 31 0b 30 09 06 03 55 04 06 13 02 55 53 31 13 30 11 06 03 55 04 08 13 0a 43 61 6c 69 66 6f 72 6e 69 61 31 13 30 11 06 03 55 04 07 13 0a 4d 65 6e 6c 6f 20 50 61 72 6b 31 17 30 15 06 03 55 04 0a 13 0e 46 61 63 65 62 6f 6f 6b 2c 20 49 6e 63 2e 31 17 30 15 06 03 55 04 03 0c 0e 2a 2e 66 61 63 65 62 6f 6f 6b 2e 63 6f 6d 
|  |- SubjectPublicKeyInfo (0x59 bytes)
|  |    30 59 
|  |    |- AlgorithmIdentifier (0x13 bytes)
|  |    |  30 13
|  |    |     06 07 2a 86 48 ce 3d 02 01     ;Algorithm Object Identifier - 1.2.840.10045.2.1   ecPublicKey (ANSI X9.62 public key type)
|  |    |     06 08 2a 86 48 ce 3d 03 01 07  ;Algorithm Object Identiifer - 1.2.840.10045.3.1.7 prime256v1  (ANSI X9.62 named elliptic curve)
|  |    |- SubjectPublicKey (0x42 bytes)
|  |       03 42           
|  |          00 04 a0 f1 8c af a7 39 88 68  5b 13 56 0e 15 15 b4 a7 45 ef 
|  |          1b c7 e5 85 3c 2b 04 d4 65 8a  31 31 22 ea a3 92 ed 64 9d ba 
|  |          65 81 e3 b6 12 76 d8 b3 0b 45  f1 ff 0a 28 14 9c 4f dc 73 a9 
|  |          b3 49 2d a0 76 d3
|  |- issuerUniqueID [0]
|       a3 82 05 4a
|          30 82 05 46 30 1f 06 03 55 1d  23 04 18 30 16 80 14 51 68 ff  90 af 02 07 75 3c cc d9 65 64  62 a2 12 b8 59 72 3b 30 1d 06 
|          4b 8f 54 e3 e7 11 5a a1 5a 07 74 6a 8b 09 ff c7 8b e5 6f d0 84 72 78 f2 85 04 24 96 d3 ed de 03 9f 3d f9 69 c2 0c cc 1c 
|          26 50 58 79 95 7c 32 5b c7 15 98 37 6b ae 94 87 1f ce 02 fa 1e b5 bd 26 0a d5 29 9e 62 04 53 02 d7 fd e3 0d 12 f8 e0 da 
|          a4 c7 df fd f7 ca c0 a8 da 5d b9 fb f1 1c 47 cb a9 17 ed 8a 21 c9 a7 93 95 b0 68 9c df ab b7 05 3d 07 38 0a f7 33 99 31 
|          da b0 98 bf 8e 65 5a 21 a2 7d 1c 2e 74 83 77 71 e7 ce 13 41 7d ba 94 32 dd 74 5f cb 8b 8b 84 6c 9e d3 4a 8a 67 4f 38 d0 
|          75 60 6d 59 b3 05 87 76 dc 7e 11 42 29 aa 8a da 42 09 57 76 e0 ba 9e 47 89 b1 27 67 62 cf 9b a9 5e 91 8d 3b d9 91 42 18 
|          ce 10 61 ce 2e 92 ac e8 bb 62 56 09 19 86 a3 47 4c 1c 98 67 bd 05 e9 9c 84 06 c0 04 ea 08 3e 10 d4 00 76 00 56 14 06 9a 
|          2f d7 c2 ec d3 f5 e1 bd 44 b2 3e c7 46 76 b9 bc 99 11 5c c0 ef 94 98 55 d6 89 d0 dd 00 00 01 58 e5 d3 62 b9 00 00 04 03 
|          00 47 30 45 02 20 1a 15 d7 6f 05 0e e5 b0 f8 4e cf d0 d2 0a 99 c1 44 b6 be 5f c0 e0 77 a6 93 ba 2f c6 5f 36 bf da 02 21 
|          00 9b b6 47 e5 0d 76 dc ba 76 38 30 04 02 6c a9 67 7a c3 c6 73 f9 df b4 0f 38 c4 38 49 a7 11 47 59 00 77 00 ee 4b bd b7 
|          75 ce 60 ba e1 42 69 1f ab e1 9e 66 a3 0f 7e 5f b0 72 d8 83 00 c4 7b 89 7a a8 fd cb 00 00 01 58 e5 d3 64 11 00 00 04 03 
|          00 48 30 46 02 21 00 ab 9b 9e 04 28 6b 92 1a 93 c7 82 3a b7 df 1f b5 f1 dc 03 f5 34 c6 f9 a4 5c 37 e6 7b 76 55 27 91 02 
|          21 00 e3 b2 aa d5 44 1c 0d 72 04 b1 5f 96 9e e3 dd f4 b3 39 92 97 5e bb 4f 93 88 72 ad 4c b4 50 af 4b 
|- signatureAlgorithm
|    30 0d 06 09 2a 86 48 86 f7 0d 01 01 0b 05 00 
|- signatureValue
     03 82 01 01
        00 3a cd 4a ca 28 9d b8 f5  60 68 f0 cb db 7d c0 ff  7e 91 90 70 ac d3 0e da  7e 4d e5 f4 0d 84 66 b0 
        90 40 17 fa 55 e5 ce 09 b7  4e a6 25 4c d8 ba b0 21  5b 3c 10 04 ae 29 b7 68  c5 65 5a e3 a5 72 d8 27 
        8e d0 1d 99 d5 99 e2 a1 0e  36 b0 4b 1c f1 a0 ba 40  c9 dd 47 a7 fc 40 bf 83  02 ba 29 d0 42 6f 84 ed 
        a7 a3 0c 3d 8d 5c 85 bf dc  89 32 e2 dd 05 14 53 88  78 38 95 aa 52 3b dc 70  10 83 b3 f2 f2 74 d8 ca 
        59 96 53 c4 b2 66 c5 14 a6  7e 9c 82 53 7b 94 d9 71  c7 30 d9 68 f1 44 c8 96  a6 6c 3a d7 6a 86 0e ff 
        43 f7 2f 30 31 c3 91 c2 3f  b6 a7 a5 9a 0d 0c 0f 61  fd 2a 97 26 02 f5 64 c2  08 e7 f8 15 69 bf 91 c4 
        2e 5f b4 10 fd 14 85 89 27  23 50 7a 2c 17 9c 26 e8  fb 8c 8d ba 79 76 5d 5f  7e 42 62 4a 48 fd 26 40 
        f4 a2 be 39 82 87 87 ab c2  c4 aa a7 45 9f 59 41 43  a3 5e 72 16 29 07 95 e4  78

Сколько много всего

Нас интересует единственная часть SubjectPublicKeyInfo:

SubjectPublicKeyInfo (0x59 bytes)
|    30 59 
|    |- AlgorithmIdentifier (0x13 bytes)
|    |  30 13
|    |     06 07 2a 86 48 ce 3d 02 01     ;Algorithm Object Identifier - 1.2.840.10045.2.1   ecPublicKey (ANSI X9.62 public key type)
|    |     06 08 2a 86 48 ce 3d 03 01 07  ;Algorithm Object Identiifer - 1.2.840.10045.3.1.7 prime256v1  (ANSI X9.62 named elliptic curve)
|    |- SubjectPublicKey (0x42 bytes)
|       03 42           
|          00 04 a0 f1 8c af a7 39 88 68  5b 13 56 0e 15 15 b4 a7 45 ef 
|          1b c7 e5 85 3c 2b 04 d4 65 8a  31 31 22 ea a3 92 ed 64 9d ba 
|          65 81 e3 b6 12 76 d8 b3 0b 45  f1 ff 0a 28 14 9c 4f dc 73 a9 
|          b3 49 2d a0 76 d3

Если вы берете только эти байты:

30 59 30 13 06 07 2a 86 48 ce  3d 02 01 06 08 2a 86 48 ce 3d
03 01 07 03 42 00 04 a0 f1 8c  af a7 39 88 68 5b 13 56 0e 15 
15 b4 a7 45 ef 1b c7 e5 85 3c  2b 04 d4 65 8a 31 31 22 ea a3 
92 ed 64 9d ba 65 81 e3 b6 12  76 d8 b3 0b 45 f1 ff 0a 28 14 
9c 4f dc 73 a9 b3 49 2d a0 76  d3

и вычислите из них SHA256, получите:

SHA256: 854206f3b721ef511941885904492ad952812e386eb2c530ee747cc32b98eeb6 (hex)
Затем вы закодируете это base64 и получите:

base64: hUIG87ch71EZQYhZBEkq2VKBLjhussUw7nR8wyuY7rY=
Это хеш, который вы добавляете в заголовки HTTP-ответа:

Public-Key-Pins: max-age=31536000; pin-sha256="hUIG87ch71EZQYhZBEkq2VKBLjhussUw7nR8wyuY7rY=";

Почему SubjectPublicKeyInfo?
Открытый ключ - это число (или в случае RSA пара чисел):

экспонента (например, 65,537)
модуль (например, сто пятьдесят четыре миллиона гугол гугол гугол )
На протяжении многих лет существует несколько способов хранения этих двух чисел:

SHH:

[lenghPrefix]ssh-rsa[lengthPrefix][exponent][lengthPrefix][modulus]

Xml:

<RSAKeyValue>
   <Modulus>ANxn+vSe8nIdRSy0gHkGoJQnUIIJ3WfOV7hsSk9An9LRafuZXYUMB6H5RxtWFm72f7nPKlg2N5kpqk+oEuhPx4IrnXIqnN5vwu4Sbc/w8rjE3XxcGsgXUams3wgiBJ0r1/lLCd6a61xRGtj4+Vae+Ps3mz/TdGUkDf80dVek9b9V</Modulus>
   <Exponent>AQAB</Exponent>
</RSAKeyValue>

PKCS#1

-----BEGIN RSA PUBLIC KEY-----
MIGJAoGBANxn+vSe8nIdRSy0gHkGoJQnUIIJ3WfOV7hsSk9An9LRafuZXY
UMB6H5RxtWFm72f7nPKlg2N5kpqk+oEuhPx4IrnXIqnN5vwu4Sbc/w8rjE
3XxcGsgXUams3wgiBJ0r1/lLCd6a61xRGtj4+Vae+Ps3mz/TdGUkDf80dV
ek9b9VAgMBAAE=
-----END RSA PUBLIC KEY-----

PKCS#1 решил использовать вариант DER кодировки ASN.1 следующей структуры:

RSAPublicKey ::= SEQUENCE {
      modulus           INTEGER,  -- n
      publicExponent    INTEGER   -- e
  }

Позже, когда появились новые системы шифрования с открытым ключом, они «заимствовали» структуру RSAPublicKey , но добавили префикс с идентификатором алгоритма :

SubjectPublicKeyInfo  ::=  SEQUENCE  {
    algorithm            AlgorithmIdentifier,
    subjectPublicKey     RSAPublicKey }

Где AlgorithID для PKCS#1 RSAPublicKey это 1.2.840.113549.1.1.1, которое следует из:

1 - ISO присвоил OIDs
1.2 - ISO номер органа
1.2.840 - USA
1.2.840.113549 - RSADSI
1.2.840.113549.1 - PKCS
1.2.840.113549.1.1 - PKCS-1
Этот формат будет отображаться в файлах в кодировке base64 как:

-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcZ/r0nvJyHUUstIB5BqCUJ1CC
Cd1nzle4bEpPQJ/S0Wn7mV2FDAeh+UcbVhZu9n+5zypYNjeZKapPqBLoT8eCK51y
Kpzeb8LuEm3P8PK4xN18XBrIF1GprN8IIgSdK9f5SwnemutcURrY+PlWnvj7N5s/
03RlJA3/NHVXpPW/VQIDAQAB
-----END PUBLIC KEY-----

Это SubjectPublicKeyInfo , из которого вы получаете хэш sha256.

Внутри каждого сертификата есть SubjectPublicKeyInfo ; даже сертификат Windows EFS.

Вы можете использовать OpenSSL для:

распакуйте блок SubjectPublicKeyInfo и сохраните его как файл BEGIN PUBLIC KEY
хэш это
Base64 это
Люди должны перестать относиться к OpenSSL как к магической криптокоробке. Слишком часто люди просто вводят эзотерические команды openssl, чтобы что-то сделать, вместо того, чтобы понимать, что они делают. Даже сам RFC по Pinning с открытым ключом не потрудится объяснить, что это такое, а просто скажет вам пойти на всезнающий openssl. OpenSSL - это не начало и не конец управления шифрованием.
